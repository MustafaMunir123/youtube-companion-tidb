"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/jotai";
exports.ids = ["vendor-chunks/jotai"];
exports.modules = {

/***/ "(ssr)/./node_modules/jotai/esm/react.mjs":
/*!******************************************!*\
  !*** ./node_modules/jotai/esm/react.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Provider: () => (/* binding */ Provider),\n/* harmony export */   useAtom: () => (/* binding */ useAtom),\n/* harmony export */   useAtomValue: () => (/* binding */ useAtomValue),\n/* harmony export */   useSetAtom: () => (/* binding */ useSetAtom),\n/* harmony export */   useStore: () => (/* binding */ useStore)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jotai/vanilla */ \"(ssr)/./node_modules/jotai/esm/vanilla.mjs\");\n/* __next_internal_client_entry_do_not_use__ Provider,useAtom,useAtomValue,useSetAtom,useStore auto */ \n\nconst StoreContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(void 0);\nconst useStore = (options)=>{\n    const store = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(StoreContext);\n    return (options == null ? void 0 : options.store) || store || (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__.getDefaultStore)();\n};\nconst Provider = ({ children, store })=>{\n    const storeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    if (!store && !storeRef.current) {\n        storeRef.current = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__.createStore)();\n    }\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(StoreContext.Provider, {\n        value: store || storeRef.current\n    }, children);\n};\nconst isPromiseLike = (x)=>typeof (x == null ? void 0 : x.then) === \"function\";\nconst use = react__WEBPACK_IMPORTED_MODULE_0__.use || ((promise)=>{\n    if (promise.status === \"pending\") {\n        throw promise;\n    } else if (promise.status === \"fulfilled\") {\n        return promise.value;\n    } else if (promise.status === \"rejected\") {\n        throw promise.reason;\n    } else {\n        promise.status = \"pending\";\n        promise.then((v)=>{\n            promise.status = \"fulfilled\";\n            promise.value = v;\n        }, (e)=>{\n            promise.status = \"rejected\";\n            promise.reason = e;\n        });\n        throw promise;\n    }\n});\nfunction useAtomValue(atom, options) {\n    const store = useStore(options);\n    const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)((prev)=>{\n        const nextValue = store.get(atom);\n        if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom) {\n            return prev;\n        }\n        return [\n            nextValue,\n            store,\n            atom\n        ];\n    }, void 0, ()=>[\n            store.get(atom),\n            store,\n            atom\n        ]);\n    let value = valueFromReducer;\n    if (storeFromReducer !== store || atomFromReducer !== atom) {\n        rerender();\n        value = store.get(atom);\n    }\n    const delay = options == null ? void 0 : options.delay;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const unsub = store.sub(atom, ()=>{\n            if (typeof delay === \"number\") {\n                setTimeout(rerender, delay);\n                return;\n            }\n            rerender();\n        });\n        rerender();\n        return unsub;\n    }, [\n        store,\n        atom,\n        delay\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(value);\n    return isPromiseLike(value) ? use(value) : value;\n}\nfunction useSetAtom(atom, options) {\n    const store = useStore(options);\n    const setAtom = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((...args)=>{\n        if (( false ? 0 : void 0) !== \"production\" && !(\"write\" in atom)) {\n            throw new Error(\"not writable atom\");\n        }\n        return store.set(atom, ...args);\n    }, [\n        store,\n        atom\n    ]);\n    return setAtom;\n}\nfunction useAtom(atom, options) {\n    return [\n        useAtomValue(atom, options),\n        // We do wrong type assertion here, which results in throwing an error.\n        useSetAtom(atom, options)\n    ];\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFTeUIsV0FBV2QsSUFBSSxFQUFFakIsT0FBTztJQUMvQixNQUFNQyxRQUFRRixTQUFTQztJQUN2QixNQUFNZ0MsVUFBVXJDLGtEQUFXQSxDQUN6QixDQUFDLEdBQUdzQztRQUNGLElBQUksQ0FBQyxNQUFlLEdBQUcsQ0FBb0IsR0FBRyxLQUFLLE9BQU8sZ0JBQWdCLENBQUUsWUFBV2hCLElBQUcsR0FBSTtZQUM1RixNQUFNLElBQUltQixNQUFNO1FBQ2xCO1FBQ0EsT0FBT25DLE1BQU1vQyxHQUFHLENBQUNwQixTQUFTZ0I7SUFDNUIsR0FDQTtRQUFDaEM7UUFBT2dCO0tBQUs7SUFFZixPQUFPZTtBQUNUO0FBRUEsU0FBU00sUUFBUXJCLElBQUksRUFBRWpCLE9BQU87SUFDNUIsT0FBTztRQUNMZ0IsYUFBYUMsTUFBTWpCO1FBQ25CLHVFQUF1RTtRQUN2RStCLFdBQVdkLE1BQU1qQjtLQUNsQjtBQUNIO0FBRWlFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2pvdGFpL2VzbS9yZWFjdC5tanM/YWMzMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5pbXBvcnQgUmVhY3RFeHBvcnRzLCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZVJlZiwgY3JlYXRlRWxlbWVudCwgdXNlUmVkdWNlciwgdXNlRWZmZWN0LCB1c2VEZWJ1Z1ZhbHVlLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGdldERlZmF1bHRTdG9yZSwgY3JlYXRlU3RvcmUgfSBmcm9tICdqb3RhaS92YW5pbGxhJztcblxuY29uc3QgU3RvcmVDb250ZXh0ID0gY3JlYXRlQ29udGV4dChcbiAgdm9pZCAwXG4pO1xuY29uc3QgdXNlU3RvcmUgPSAob3B0aW9ucykgPT4ge1xuICBjb25zdCBzdG9yZSA9IHVzZUNvbnRleHQoU3RvcmVDb250ZXh0KTtcbiAgcmV0dXJuIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnN0b3JlKSB8fCBzdG9yZSB8fCBnZXREZWZhdWx0U3RvcmUoKTtcbn07XG5jb25zdCBQcm92aWRlciA9ICh7XG4gIGNoaWxkcmVuLFxuICBzdG9yZVxufSkgPT4ge1xuICBjb25zdCBzdG9yZVJlZiA9IHVzZVJlZigpO1xuICBpZiAoIXN0b3JlICYmICFzdG9yZVJlZi5jdXJyZW50KSB7XG4gICAgc3RvcmVSZWYuY3VycmVudCA9IGNyZWF0ZVN0b3JlKCk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoXG4gICAgU3RvcmVDb250ZXh0LlByb3ZpZGVyLFxuICAgIHtcbiAgICAgIHZhbHVlOiBzdG9yZSB8fCBzdG9yZVJlZi5jdXJyZW50XG4gICAgfSxcbiAgICBjaGlsZHJlblxuICApO1xufTtcblxuY29uc3QgaXNQcm9taXNlTGlrZSA9ICh4KSA9PiB0eXBlb2YgKHggPT0gbnVsbCA/IHZvaWQgMCA6IHgudGhlbikgPT09IFwiZnVuY3Rpb25cIjtcbmNvbnN0IHVzZSA9IFJlYWN0RXhwb3J0cy51c2UgfHwgKChwcm9taXNlKSA9PiB7XG4gIGlmIChwcm9taXNlLnN0YXR1cyA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICB0aHJvdyBwcm9taXNlO1xuICB9IGVsc2UgaWYgKHByb21pc2Uuc3RhdHVzID09PSBcImZ1bGZpbGxlZFwiKSB7XG4gICAgcmV0dXJuIHByb21pc2UudmFsdWU7XG4gIH0gZWxzZSBpZiAocHJvbWlzZS5zdGF0dXMgPT09IFwicmVqZWN0ZWRcIikge1xuICAgIHRocm93IHByb21pc2UucmVhc29uO1xuICB9IGVsc2Uge1xuICAgIHByb21pc2Uuc3RhdHVzID0gXCJwZW5kaW5nXCI7XG4gICAgcHJvbWlzZS50aGVuKFxuICAgICAgKHYpID0+IHtcbiAgICAgICAgcHJvbWlzZS5zdGF0dXMgPSBcImZ1bGZpbGxlZFwiO1xuICAgICAgICBwcm9taXNlLnZhbHVlID0gdjtcbiAgICAgIH0sXG4gICAgICAoZSkgPT4ge1xuICAgICAgICBwcm9taXNlLnN0YXR1cyA9IFwicmVqZWN0ZWRcIjtcbiAgICAgICAgcHJvbWlzZS5yZWFzb24gPSBlO1xuICAgICAgfVxuICAgICk7XG4gICAgdGhyb3cgcHJvbWlzZTtcbiAgfVxufSk7XG5mdW5jdGlvbiB1c2VBdG9tVmFsdWUoYXRvbSwgb3B0aW9ucykge1xuICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlKG9wdGlvbnMpO1xuICBjb25zdCBbW3ZhbHVlRnJvbVJlZHVjZXIsIHN0b3JlRnJvbVJlZHVjZXIsIGF0b21Gcm9tUmVkdWNlcl0sIHJlcmVuZGVyXSA9IHVzZVJlZHVjZXIoXG4gICAgKHByZXYpID0+IHtcbiAgICAgIGNvbnN0IG5leHRWYWx1ZSA9IHN0b3JlLmdldChhdG9tKTtcbiAgICAgIGlmIChPYmplY3QuaXMocHJldlswXSwgbmV4dFZhbHVlKSAmJiBwcmV2WzFdID09PSBzdG9yZSAmJiBwcmV2WzJdID09PSBhdG9tKSB7XG4gICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtuZXh0VmFsdWUsIHN0b3JlLCBhdG9tXTtcbiAgICB9LFxuICAgIHZvaWQgMCxcbiAgICAoKSA9PiBbc3RvcmUuZ2V0KGF0b20pLCBzdG9yZSwgYXRvbV1cbiAgKTtcbiAgbGV0IHZhbHVlID0gdmFsdWVGcm9tUmVkdWNlcjtcbiAgaWYgKHN0b3JlRnJvbVJlZHVjZXIgIT09IHN0b3JlIHx8IGF0b21Gcm9tUmVkdWNlciAhPT0gYXRvbSkge1xuICAgIHJlcmVuZGVyKCk7XG4gICAgdmFsdWUgPSBzdG9yZS5nZXQoYXRvbSk7XG4gIH1cbiAgY29uc3QgZGVsYXkgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmRlbGF5O1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHVuc3ViID0gc3RvcmUuc3ViKGF0b20sICgpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgZGVsYXkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgc2V0VGltZW91dChyZXJlbmRlciwgZGVsYXkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXJlbmRlcigpO1xuICAgIH0pO1xuICAgIHJlcmVuZGVyKCk7XG4gICAgcmV0dXJuIHVuc3ViO1xuICB9LCBbc3RvcmUsIGF0b20sIGRlbGF5XSk7XG4gIHVzZURlYnVnVmFsdWUodmFsdWUpO1xuICByZXR1cm4gaXNQcm9taXNlTGlrZSh2YWx1ZSkgPyB1c2UodmFsdWUpIDogdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHVzZVNldEF0b20oYXRvbSwgb3B0aW9ucykge1xuICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlKG9wdGlvbnMpO1xuICBjb25zdCBzZXRBdG9tID0gdXNlQ2FsbGJhY2soXG4gICAgKC4uLmFyZ3MpID0+IHtcbiAgICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhKFwid3JpdGVcIiBpbiBhdG9tKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3Qgd3JpdGFibGUgYXRvbVwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdG9yZS5zZXQoYXRvbSwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBbc3RvcmUsIGF0b21dXG4gICk7XG4gIHJldHVybiBzZXRBdG9tO1xufVxuXG5mdW5jdGlvbiB1c2VBdG9tKGF0b20sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIFtcbiAgICB1c2VBdG9tVmFsdWUoYXRvbSwgb3B0aW9ucyksXG4gICAgLy8gV2UgZG8gd3JvbmcgdHlwZSBhc3NlcnRpb24gaGVyZSwgd2hpY2ggcmVzdWx0cyBpbiB0aHJvd2luZyBhbiBlcnJvci5cbiAgICB1c2VTZXRBdG9tKGF0b20sIG9wdGlvbnMpXG4gIF07XG59XG5cbmV4cG9ydCB7IFByb3ZpZGVyLCB1c2VBdG9tLCB1c2VBdG9tVmFsdWUsIHVzZVNldEF0b20sIHVzZVN0b3JlIH07XG4iXSwibmFtZXMiOlsiUmVhY3RFeHBvcnRzIiwiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VSZWYiLCJjcmVhdGVFbGVtZW50IiwidXNlUmVkdWNlciIsInVzZUVmZmVjdCIsInVzZURlYnVnVmFsdWUiLCJ1c2VDYWxsYmFjayIsImdldERlZmF1bHRTdG9yZSIsImNyZWF0ZVN0b3JlIiwiU3RvcmVDb250ZXh0IiwidXNlU3RvcmUiLCJvcHRpb25zIiwic3RvcmUiLCJQcm92aWRlciIsImNoaWxkcmVuIiwic3RvcmVSZWYiLCJjdXJyZW50IiwidmFsdWUiLCJpc1Byb21pc2VMaWtlIiwieCIsInRoZW4iLCJ1c2UiLCJwcm9taXNlIiwic3RhdHVzIiwicmVhc29uIiwidiIsImUiLCJ1c2VBdG9tVmFsdWUiLCJhdG9tIiwidmFsdWVGcm9tUmVkdWNlciIsInN0b3JlRnJvbVJlZHVjZXIiLCJhdG9tRnJvbVJlZHVjZXIiLCJyZXJlbmRlciIsInByZXYiLCJuZXh0VmFsdWUiLCJnZXQiLCJPYmplY3QiLCJpcyIsImRlbGF5IiwidW5zdWIiLCJzdWIiLCJzZXRUaW1lb3V0IiwidXNlU2V0QXRvbSIsInNldEF0b20iLCJhcmdzIiwiZW52IiwiTU9ERSIsIkVycm9yIiwic2V0IiwidXNlQXRvbSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jotai/esm/react.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jotai/esm/vanilla.mjs":
/*!********************************************!*\
  !*** ./node_modules/jotai/esm/vanilla.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   atom: () => (/* binding */ atom),\n/* harmony export */   createStore: () => (/* binding */ createStore),\n/* harmony export */   getDefaultStore: () => (/* binding */ getDefaultStore)\n/* harmony export */ });\nlet keyCount = 0;\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString() {\n      return ( false ? 0 : void 0) !== \"production\" && this.debugLabel ? key + \":\" + this.debugLabel : key;\n    }\n  };\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = defaultRead;\n    config.write = defaultWrite;\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\nfunction defaultRead(get) {\n  return get(this);\n}\nfunction defaultWrite(get, set, arg) {\n  return set(\n    this,\n    typeof arg === \"function\" ? arg(get(this)) : arg\n  );\n}\n\nconst isSelfAtom = (atom, a) => atom.unstable_is ? atom.unstable_is(a) : a === atom;\nconst hasInitialValue = (atom) => \"init\" in atom;\nconst isActuallyWritableAtom = (atom) => !!atom.write;\nconst CONTINUE_PROMISE = Symbol(\n  ( false ? 0 : void 0) !== \"production\" ? \"CONTINUE_PROMISE\" : \"\"\n);\nconst PENDING = \"pending\";\nconst FULFILLED = \"fulfilled\";\nconst REJECTED = \"rejected\";\nconst isContinuablePromise = (promise) => typeof promise === \"object\" && promise !== null && CONTINUE_PROMISE in promise;\nconst continuablePromiseMap = /* @__PURE__ */ new WeakMap();\nconst createContinuablePromise = (promise, abort, complete) => {\n  if (!continuablePromiseMap.has(promise)) {\n    let continuePromise;\n    const p = new Promise((resolve, reject) => {\n      let curr = promise;\n      const onFulfilled = (me) => (v) => {\n        if (curr === me) {\n          p.status = FULFILLED;\n          p.value = v;\n          resolve(v);\n          complete();\n        }\n      };\n      const onRejected = (me) => (e) => {\n        if (curr === me) {\n          p.status = REJECTED;\n          p.reason = e;\n          reject(e);\n          complete();\n        }\n      };\n      promise.then(onFulfilled(promise), onRejected(promise));\n      continuePromise = (nextPromise, nextAbort) => {\n        if (nextPromise) {\n          continuablePromiseMap.set(nextPromise, p);\n          curr = nextPromise;\n          nextPromise.then(onFulfilled(nextPromise), onRejected(nextPromise));\n          abort();\n          abort = nextAbort;\n        }\n      };\n    });\n    p.status = PENDING;\n    p[CONTINUE_PROMISE] = continuePromise;\n    continuablePromiseMap.set(promise, p);\n  }\n  return continuablePromiseMap.get(promise);\n};\nconst isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nconst isAtomStateInitialized = (atomState) => \"v\" in atomState || \"e\" in atomState;\nconst returnAtomValue = (atomState) => {\n  if (\"e\" in atomState) {\n    throw atomState.e;\n  }\n  if (( false ? 0 : void 0) !== \"production\" && !(\"v\" in atomState)) {\n    throw new Error(\"[Bug] atom state is not initialized\");\n  }\n  return atomState.v;\n};\nconst getPendingContinuablePromise = (atomState) => {\n  const value = atomState.v;\n  if (isContinuablePromise(value) && value.status === PENDING) {\n    return value;\n  }\n  return null;\n};\nconst addPendingContinuablePromiseToDependency = (atom, promise, dependencyAtomState) => {\n  if (!dependencyAtomState.p.has(atom)) {\n    dependencyAtomState.p.add(atom);\n    promise.then(\n      () => {\n        dependencyAtomState.p.delete(atom);\n      },\n      () => {\n        dependencyAtomState.p.delete(atom);\n      }\n    );\n  }\n};\nconst createPending = () => [/* @__PURE__ */ new Map(), /* @__PURE__ */ new Map(), /* @__PURE__ */ new Set()];\nconst addPendingAtom = (pending, atom, atomState) => {\n  if (!pending[0].has(atom)) {\n    pending[0].set(atom, /* @__PURE__ */ new Set());\n  }\n  pending[1].set(atom, atomState);\n};\nconst addPendingDependent = (pending, atom, dependent) => {\n  const dependents = pending[0].get(atom);\n  if (dependents) {\n    dependents.add(dependent);\n  }\n};\nconst getPendingDependents = (pending, atom) => pending[0].get(atom);\nconst addPendingFunction = (pending, fn) => {\n  pending[2].add(fn);\n};\nconst flushPending = (pending) => {\n  while (pending[1].size || pending[2].size) {\n    pending[0].clear();\n    const atomStates = new Set(pending[1].values());\n    pending[1].clear();\n    const functions = new Set(pending[2]);\n    pending[2].clear();\n    atomStates.forEach((atomState) => {\n      var _a;\n      return (_a = atomState.m) == null ? void 0 : _a.l.forEach((l) => l());\n    });\n    functions.forEach((fn) => fn());\n  }\n};\nconst createStore = () => {\n  const atomStateMap = /* @__PURE__ */ new WeakMap();\n  let debugMountedAtoms;\n  if (( false ? 0 : void 0) !== \"production\") {\n    debugMountedAtoms = /* @__PURE__ */ new Set();\n  }\n  const getAtomState = (atom) => {\n    let atomState = atomStateMap.get(atom);\n    if (!atomState) {\n      atomState = { d: /* @__PURE__ */ new Map(), p: /* @__PURE__ */ new Set(), n: 0 };\n      atomStateMap.set(atom, atomState);\n    }\n    return atomState;\n  };\n  const setAtomStateValueOrPromise = (atom, atomState, valueOrPromise, abortPromise = () => {\n  }, completePromise = () => {\n  }) => {\n    const hasPrevValue = \"v\" in atomState;\n    const prevValue = atomState.v;\n    const pendingPromise = getPendingContinuablePromise(atomState);\n    if (isPromiseLike(valueOrPromise)) {\n      if (pendingPromise) {\n        if (pendingPromise !== valueOrPromise) {\n          pendingPromise[CONTINUE_PROMISE](valueOrPromise, abortPromise);\n          ++atomState.n;\n        }\n      } else {\n        const continuablePromise = createContinuablePromise(\n          valueOrPromise,\n          abortPromise,\n          completePromise\n        );\n        if (continuablePromise.status === PENDING) {\n          for (const a of atomState.d.keys()) {\n            const aState = getAtomState(a);\n            addPendingContinuablePromiseToDependency(\n              atom,\n              continuablePromise,\n              aState\n            );\n          }\n        }\n        atomState.v = continuablePromise;\n        delete atomState.e;\n      }\n    } else {\n      if (pendingPromise) {\n        pendingPromise[CONTINUE_PROMISE](\n          Promise.resolve(valueOrPromise),\n          abortPromise\n        );\n      }\n      atomState.v = valueOrPromise;\n      delete atomState.e;\n    }\n    if (!hasPrevValue || !Object.is(prevValue, atomState.v)) {\n      ++atomState.n;\n    }\n  };\n  const addDependency = (pending, atom, a, aState) => {\n    var _a;\n    if (( false ? 0 : void 0) !== \"production\" && a === atom) {\n      throw new Error(\"[Bug] atom cannot depend on itself\");\n    }\n    const atomState = getAtomState(atom);\n    atomState.d.set(a, aState.n);\n    const continuablePromise = getPendingContinuablePromise(atomState);\n    if (continuablePromise) {\n      addPendingContinuablePromiseToDependency(atom, continuablePromise, aState);\n    }\n    (_a = aState.m) == null ? void 0 : _a.t.add(atom);\n    if (pending) {\n      addPendingDependent(pending, a, atom);\n    }\n  };\n  const readAtomState = (pending, atom, force) => {\n    const atomState = getAtomState(atom);\n    if (!(force == null ? void 0 : force(atom)) && isAtomStateInitialized(atomState)) {\n      if (atomState.m) {\n        return atomState;\n      }\n      if (Array.from(atomState.d).every(\n        ([a, n]) => (\n          // Recursively, read the atom state of the dependency, and\n          // check if the atom epoch number is unchanged\n          readAtomState(pending, a, force).n === n\n        )\n      )) {\n        return atomState;\n      }\n    }\n    atomState.d.clear();\n    let isSync = true;\n    const getter = (a) => {\n      if (isSelfAtom(atom, a)) {\n        const aState2 = getAtomState(a);\n        if (!isAtomStateInitialized(aState2)) {\n          if (hasInitialValue(a)) {\n            setAtomStateValueOrPromise(a, aState2, a.init);\n          } else {\n            throw new Error(\"no atom init\");\n          }\n        }\n        return returnAtomValue(aState2);\n      }\n      const aState = readAtomState(pending, a, force);\n      if (isSync) {\n        addDependency(pending, atom, a, aState);\n      } else {\n        const pending2 = createPending();\n        addDependency(pending2, atom, a, aState);\n        mountDependencies(pending2, atom, atomState);\n        flushPending(pending2);\n      }\n      return returnAtomValue(aState);\n    };\n    let controller;\n    let setSelf;\n    const options = {\n      get signal() {\n        if (!controller) {\n          controller = new AbortController();\n        }\n        return controller.signal;\n      },\n      get setSelf() {\n        if (( false ? 0 : void 0) !== \"production\" && !isActuallyWritableAtom(atom)) {\n          console.warn(\"setSelf function cannot be used with read-only atom\");\n        }\n        if (!setSelf && isActuallyWritableAtom(atom)) {\n          setSelf = (...args) => {\n            if (( false ? 0 : void 0) !== \"production\" && isSync) {\n              console.warn(\"setSelf function cannot be called in sync\");\n            }\n            if (!isSync) {\n              return writeAtom(atom, ...args);\n            }\n          };\n        }\n        return setSelf;\n      }\n    };\n    try {\n      const valueOrPromise = atom.read(getter, options);\n      setAtomStateValueOrPromise(\n        atom,\n        atomState,\n        valueOrPromise,\n        () => controller == null ? void 0 : controller.abort(),\n        () => {\n          if (atomState.m) {\n            const pending2 = createPending();\n            mountDependencies(pending2, atom, atomState);\n            flushPending(pending2);\n          }\n        }\n      );\n      return atomState;\n    } catch (error) {\n      delete atomState.v;\n      atomState.e = error;\n      ++atomState.n;\n      return atomState;\n    } finally {\n      isSync = false;\n    }\n  };\n  const readAtom = (atom) => returnAtomValue(readAtomState(void 0, atom));\n  const recomputeDependents = (pending, atom) => {\n    const getDependents = (a) => {\n      var _a, _b;\n      const aState = getAtomState(a);\n      const dependents = new Set((_a = aState.m) == null ? void 0 : _a.t);\n      for (const atomWithPendingContinuablePromise of aState.p) {\n        dependents.add(atomWithPendingContinuablePromise);\n      }\n      (_b = getPendingDependents(pending, a)) == null ? void 0 : _b.forEach((dependent) => {\n        dependents.add(dependent);\n      });\n      return dependents;\n    };\n    const topsortedAtoms = [];\n    const markedAtoms = /* @__PURE__ */ new Set();\n    const visit = (n) => {\n      if (markedAtoms.has(n)) {\n        return;\n      }\n      markedAtoms.add(n);\n      for (const m of getDependents(n)) {\n        if (n !== m) {\n          visit(m);\n        }\n      }\n      topsortedAtoms.push(n);\n    };\n    visit(atom);\n    const changedAtoms = /* @__PURE__ */ new Set([atom]);\n    const isMarked = (a) => markedAtoms.has(a);\n    for (let i = topsortedAtoms.length - 1; i >= 0; --i) {\n      const a = topsortedAtoms[i];\n      const aState = getAtomState(a);\n      const prevEpochNumber = aState.n;\n      let hasChangedDeps = false;\n      for (const dep of aState.d.keys()) {\n        if (dep !== a && changedAtoms.has(dep)) {\n          hasChangedDeps = true;\n          break;\n        }\n      }\n      if (hasChangedDeps) {\n        readAtomState(pending, a, isMarked);\n        mountDependencies(pending, a, aState);\n        if (prevEpochNumber !== aState.n) {\n          addPendingAtom(pending, a, aState);\n          changedAtoms.add(a);\n        }\n      }\n      markedAtoms.delete(a);\n    }\n  };\n  const writeAtomState = (pending, atom, ...args) => {\n    const getter = (a) => returnAtomValue(readAtomState(pending, a));\n    const setter = (a, ...args2) => {\n      let r;\n      if (isSelfAtom(atom, a)) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        const aState = getAtomState(a);\n        const hasPrevValue = \"v\" in aState;\n        const prevValue = aState.v;\n        const v = args2[0];\n        setAtomStateValueOrPromise(a, aState, v);\n        mountDependencies(pending, a, aState);\n        if (!hasPrevValue || !Object.is(prevValue, aState.v)) {\n          addPendingAtom(pending, a, aState);\n          recomputeDependents(pending, a);\n        }\n      } else {\n        r = writeAtomState(pending, a, ...args2);\n      }\n      flushPending(pending);\n      return r;\n    };\n    const result = atom.write(getter, setter, ...args);\n    return result;\n  };\n  const writeAtom = (atom, ...args) => {\n    const pending = createPending();\n    const result = writeAtomState(pending, atom, ...args);\n    flushPending(pending);\n    return result;\n  };\n  const mountDependencies = (pending, atom, atomState) => {\n    if (atomState.m && !getPendingContinuablePromise(atomState)) {\n      for (const a of atomState.d.keys()) {\n        if (!atomState.m.d.has(a)) {\n          const aMounted = mountAtom(pending, a);\n          aMounted.t.add(atom);\n          atomState.m.d.add(a);\n        }\n      }\n      for (const a of atomState.m.d || []) {\n        if (!atomState.d.has(a)) {\n          atomState.m.d.delete(a);\n          const aMounted = unmountAtom(pending, a);\n          aMounted == null ? void 0 : aMounted.t.delete(atom);\n        }\n      }\n    }\n  };\n  const mountAtom = (pending, atom) => {\n    const atomState = getAtomState(atom);\n    if (!atomState.m) {\n      readAtomState(pending, atom);\n      for (const a of atomState.d.keys()) {\n        const aMounted = mountAtom(pending, a);\n        aMounted.t.add(atom);\n      }\n      atomState.m = {\n        l: /* @__PURE__ */ new Set(),\n        d: new Set(atomState.d.keys()),\n        t: /* @__PURE__ */ new Set()\n      };\n      if (( false ? 0 : void 0) !== \"production\") {\n        debugMountedAtoms.add(atom);\n      }\n      if (isActuallyWritableAtom(atom) && atom.onMount) {\n        const mounted = atomState.m;\n        const { onMount } = atom;\n        addPendingFunction(pending, () => {\n          const onUnmount = onMount(\n            (...args) => writeAtomState(pending, atom, ...args)\n          );\n          if (onUnmount) {\n            mounted.u = onUnmount;\n          }\n        });\n      }\n    }\n    return atomState.m;\n  };\n  const unmountAtom = (pending, atom) => {\n    const atomState = getAtomState(atom);\n    if (atomState.m && !atomState.m.l.size && !Array.from(atomState.m.t).some((a) => {\n      var _a;\n      return (_a = getAtomState(a).m) == null ? void 0 : _a.d.has(atom);\n    })) {\n      const onUnmount = atomState.m.u;\n      if (onUnmount) {\n        addPendingFunction(pending, onUnmount);\n      }\n      delete atomState.m;\n      if (( false ? 0 : void 0) !== \"production\") {\n        debugMountedAtoms.delete(atom);\n      }\n      for (const a of atomState.d.keys()) {\n        const aMounted = unmountAtom(pending, a);\n        aMounted == null ? void 0 : aMounted.t.delete(atom);\n      }\n      const pendingPromise = getPendingContinuablePromise(atomState);\n      if (pendingPromise) {\n        pendingPromise[CONTINUE_PROMISE](void 0, () => {\n        });\n      }\n      return void 0;\n    }\n    return atomState.m;\n  };\n  const subscribeAtom = (atom, listener) => {\n    const pending = createPending();\n    const mounted = mountAtom(pending, atom);\n    flushPending(pending);\n    const listeners = mounted.l;\n    listeners.add(listener);\n    return () => {\n      listeners.delete(listener);\n      const pending2 = createPending();\n      unmountAtom(pending2, atom);\n      flushPending(pending2);\n    };\n  };\n  const store = {\n    get: readAtom,\n    set: writeAtom,\n    sub: subscribeAtom\n  };\n  if (( false ? 0 : void 0) !== \"production\") {\n    const devStore = {\n      // store dev methods (these are tentative and subject to change without notice)\n      dev4_get_internal_weak_map: () => atomStateMap,\n      dev4_get_mounted_atoms: () => debugMountedAtoms,\n      dev4_restore_atoms: (values) => {\n        const pending = createPending();\n        for (const [atom, value] of values) {\n          if (hasInitialValue(atom)) {\n            const atomState = getAtomState(atom);\n            const hasPrevValue = \"v\" in atomState;\n            const prevValue = atomState.v;\n            setAtomStateValueOrPromise(atom, atomState, value);\n            mountDependencies(pending, atom, atomState);\n            if (!hasPrevValue || !Object.is(prevValue, atomState.v)) {\n              addPendingAtom(pending, atom, atomState);\n              recomputeDependents(pending, atom);\n            }\n          }\n        }\n        flushPending(pending);\n      }\n    };\n    Object.assign(store, devStore);\n  }\n  return store;\n};\nlet defaultStore;\nconst getDefaultStore = () => {\n  if (!defaultStore) {\n    defaultStore = createStore();\n    if (( false ? 0 : void 0) !== \"production\") {\n      globalThis.__JOTAI_DEFAULT_STORE__ || (globalThis.__JOTAI_DEFAULT_STORE__ = defaultStore);\n      if (globalThis.__JOTAI_DEFAULT_STORE__ !== defaultStore) {\n        console.warn(\n          \"Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044\"\n        );\n      }\n    }\n  }\n  return defaultStore;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam90YWkvZXNtL3ZhbmlsbGEubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQSxxQkFBcUIsV0FBVztBQUNoQztBQUNBO0FBQ0EsY0FBYyxNQUFlLEdBQUcsQ0FBb0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxNQUFlLEdBQUcsQ0FBb0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxNQUFlLEdBQUcsQ0FBb0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLE1BQWUsR0FBRyxDQUFvQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLE1BQWUsR0FBRyxDQUFvQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFOEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvam90YWkvZXNtL3ZhbmlsbGEubWpzP2Q0YWQiXSwic291cmNlc0NvbnRlbnQiOlsibGV0IGtleUNvdW50ID0gMDtcbmZ1bmN0aW9uIGF0b20ocmVhZCwgd3JpdGUpIHtcbiAgY29uc3Qga2V5ID0gYGF0b20keysra2V5Q291bnR9YDtcbiAgY29uc3QgY29uZmlnID0ge1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiICYmIHRoaXMuZGVidWdMYWJlbCA/IGtleSArIFwiOlwiICsgdGhpcy5kZWJ1Z0xhYmVsIDoga2V5O1xuICAgIH1cbiAgfTtcbiAgaWYgKHR5cGVvZiByZWFkID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjb25maWcucmVhZCA9IHJlYWQ7XG4gIH0gZWxzZSB7XG4gICAgY29uZmlnLmluaXQgPSByZWFkO1xuICAgIGNvbmZpZy5yZWFkID0gZGVmYXVsdFJlYWQ7XG4gICAgY29uZmlnLndyaXRlID0gZGVmYXVsdFdyaXRlO1xuICB9XG4gIGlmICh3cml0ZSkge1xuICAgIGNvbmZpZy53cml0ZSA9IHdyaXRlO1xuICB9XG4gIHJldHVybiBjb25maWc7XG59XG5mdW5jdGlvbiBkZWZhdWx0UmVhZChnZXQpIHtcbiAgcmV0dXJuIGdldCh0aGlzKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRXcml0ZShnZXQsIHNldCwgYXJnKSB7XG4gIHJldHVybiBzZXQoXG4gICAgdGhpcyxcbiAgICB0eXBlb2YgYXJnID09PSBcImZ1bmN0aW9uXCIgPyBhcmcoZ2V0KHRoaXMpKSA6IGFyZ1xuICApO1xufVxuXG5jb25zdCBpc1NlbGZBdG9tID0gKGF0b20sIGEpID0+IGF0b20udW5zdGFibGVfaXMgPyBhdG9tLnVuc3RhYmxlX2lzKGEpIDogYSA9PT0gYXRvbTtcbmNvbnN0IGhhc0luaXRpYWxWYWx1ZSA9IChhdG9tKSA9PiBcImluaXRcIiBpbiBhdG9tO1xuY29uc3QgaXNBY3R1YWxseVdyaXRhYmxlQXRvbSA9IChhdG9tKSA9PiAhIWF0b20ud3JpdGU7XG5jb25zdCBDT05USU5VRV9QUk9NSVNFID0gU3ltYm9sKFxuICAoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIiA/IFwiQ09OVElOVUVfUFJPTUlTRVwiIDogXCJcIlxuKTtcbmNvbnN0IFBFTkRJTkcgPSBcInBlbmRpbmdcIjtcbmNvbnN0IEZVTEZJTExFRCA9IFwiZnVsZmlsbGVkXCI7XG5jb25zdCBSRUpFQ1RFRCA9IFwicmVqZWN0ZWRcIjtcbmNvbnN0IGlzQ29udGludWFibGVQcm9taXNlID0gKHByb21pc2UpID0+IHR5cGVvZiBwcm9taXNlID09PSBcIm9iamVjdFwiICYmIHByb21pc2UgIT09IG51bGwgJiYgQ09OVElOVUVfUFJPTUlTRSBpbiBwcm9taXNlO1xuY29uc3QgY29udGludWFibGVQcm9taXNlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jb25zdCBjcmVhdGVDb250aW51YWJsZVByb21pc2UgPSAocHJvbWlzZSwgYWJvcnQsIGNvbXBsZXRlKSA9PiB7XG4gIGlmICghY29udGludWFibGVQcm9taXNlTWFwLmhhcyhwcm9taXNlKSkge1xuICAgIGxldCBjb250aW51ZVByb21pc2U7XG4gICAgY29uc3QgcCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxldCBjdXJyID0gcHJvbWlzZTtcbiAgICAgIGNvbnN0IG9uRnVsZmlsbGVkID0gKG1lKSA9PiAodikgPT4ge1xuICAgICAgICBpZiAoY3VyciA9PT0gbWUpIHtcbiAgICAgICAgICBwLnN0YXR1cyA9IEZVTEZJTExFRDtcbiAgICAgICAgICBwLnZhbHVlID0gdjtcbiAgICAgICAgICByZXNvbHZlKHYpO1xuICAgICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBvblJlamVjdGVkID0gKG1lKSA9PiAoZSkgPT4ge1xuICAgICAgICBpZiAoY3VyciA9PT0gbWUpIHtcbiAgICAgICAgICBwLnN0YXR1cyA9IFJFSkVDVEVEO1xuICAgICAgICAgIHAucmVhc29uID0gZTtcbiAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHByb21pc2UudGhlbihvbkZ1bGZpbGxlZChwcm9taXNlKSwgb25SZWplY3RlZChwcm9taXNlKSk7XG4gICAgICBjb250aW51ZVByb21pc2UgPSAobmV4dFByb21pc2UsIG5leHRBYm9ydCkgPT4ge1xuICAgICAgICBpZiAobmV4dFByb21pc2UpIHtcbiAgICAgICAgICBjb250aW51YWJsZVByb21pc2VNYXAuc2V0KG5leHRQcm9taXNlLCBwKTtcbiAgICAgICAgICBjdXJyID0gbmV4dFByb21pc2U7XG4gICAgICAgICAgbmV4dFByb21pc2UudGhlbihvbkZ1bGZpbGxlZChuZXh0UHJvbWlzZSksIG9uUmVqZWN0ZWQobmV4dFByb21pc2UpKTtcbiAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIGFib3J0ID0gbmV4dEFib3J0O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICAgIHAuc3RhdHVzID0gUEVORElORztcbiAgICBwW0NPTlRJTlVFX1BST01JU0VdID0gY29udGludWVQcm9taXNlO1xuICAgIGNvbnRpbnVhYmxlUHJvbWlzZU1hcC5zZXQocHJvbWlzZSwgcCk7XG4gIH1cbiAgcmV0dXJuIGNvbnRpbnVhYmxlUHJvbWlzZU1hcC5nZXQocHJvbWlzZSk7XG59O1xuY29uc3QgaXNQcm9taXNlTGlrZSA9ICh4KSA9PiB0eXBlb2YgKHggPT0gbnVsbCA/IHZvaWQgMCA6IHgudGhlbikgPT09IFwiZnVuY3Rpb25cIjtcbmNvbnN0IGlzQXRvbVN0YXRlSW5pdGlhbGl6ZWQgPSAoYXRvbVN0YXRlKSA9PiBcInZcIiBpbiBhdG9tU3RhdGUgfHwgXCJlXCIgaW4gYXRvbVN0YXRlO1xuY29uc3QgcmV0dXJuQXRvbVZhbHVlID0gKGF0b21TdGF0ZSkgPT4ge1xuICBpZiAoXCJlXCIgaW4gYXRvbVN0YXRlKSB7XG4gICAgdGhyb3cgYXRvbVN0YXRlLmU7XG4gIH1cbiAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiICYmICEoXCJ2XCIgaW4gYXRvbVN0YXRlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIltCdWddIGF0b20gc3RhdGUgaXMgbm90IGluaXRpYWxpemVkXCIpO1xuICB9XG4gIHJldHVybiBhdG9tU3RhdGUudjtcbn07XG5jb25zdCBnZXRQZW5kaW5nQ29udGludWFibGVQcm9taXNlID0gKGF0b21TdGF0ZSkgPT4ge1xuICBjb25zdCB2YWx1ZSA9IGF0b21TdGF0ZS52O1xuICBpZiAoaXNDb250aW51YWJsZVByb21pc2UodmFsdWUpICYmIHZhbHVlLnN0YXR1cyA9PT0gUEVORElORykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5jb25zdCBhZGRQZW5kaW5nQ29udGludWFibGVQcm9taXNlVG9EZXBlbmRlbmN5ID0gKGF0b20sIHByb21pc2UsIGRlcGVuZGVuY3lBdG9tU3RhdGUpID0+IHtcbiAgaWYgKCFkZXBlbmRlbmN5QXRvbVN0YXRlLnAuaGFzKGF0b20pKSB7XG4gICAgZGVwZW5kZW5jeUF0b21TdGF0ZS5wLmFkZChhdG9tKTtcbiAgICBwcm9taXNlLnRoZW4oXG4gICAgICAoKSA9PiB7XG4gICAgICAgIGRlcGVuZGVuY3lBdG9tU3RhdGUucC5kZWxldGUoYXRvbSk7XG4gICAgICB9LFxuICAgICAgKCkgPT4ge1xuICAgICAgICBkZXBlbmRlbmN5QXRvbVN0YXRlLnAuZGVsZXRlKGF0b20pO1xuICAgICAgfVxuICAgICk7XG4gIH1cbn07XG5jb25zdCBjcmVhdGVQZW5kaW5nID0gKCkgPT4gWy8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCldO1xuY29uc3QgYWRkUGVuZGluZ0F0b20gPSAocGVuZGluZywgYXRvbSwgYXRvbVN0YXRlKSA9PiB7XG4gIGlmICghcGVuZGluZ1swXS5oYXMoYXRvbSkpIHtcbiAgICBwZW5kaW5nWzBdLnNldChhdG9tLCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgfVxuICBwZW5kaW5nWzFdLnNldChhdG9tLCBhdG9tU3RhdGUpO1xufTtcbmNvbnN0IGFkZFBlbmRpbmdEZXBlbmRlbnQgPSAocGVuZGluZywgYXRvbSwgZGVwZW5kZW50KSA9PiB7XG4gIGNvbnN0IGRlcGVuZGVudHMgPSBwZW5kaW5nWzBdLmdldChhdG9tKTtcbiAgaWYgKGRlcGVuZGVudHMpIHtcbiAgICBkZXBlbmRlbnRzLmFkZChkZXBlbmRlbnQpO1xuICB9XG59O1xuY29uc3QgZ2V0UGVuZGluZ0RlcGVuZGVudHMgPSAocGVuZGluZywgYXRvbSkgPT4gcGVuZGluZ1swXS5nZXQoYXRvbSk7XG5jb25zdCBhZGRQZW5kaW5nRnVuY3Rpb24gPSAocGVuZGluZywgZm4pID0+IHtcbiAgcGVuZGluZ1syXS5hZGQoZm4pO1xufTtcbmNvbnN0IGZsdXNoUGVuZGluZyA9IChwZW5kaW5nKSA9PiB7XG4gIHdoaWxlIChwZW5kaW5nWzFdLnNpemUgfHwgcGVuZGluZ1syXS5zaXplKSB7XG4gICAgcGVuZGluZ1swXS5jbGVhcigpO1xuICAgIGNvbnN0IGF0b21TdGF0ZXMgPSBuZXcgU2V0KHBlbmRpbmdbMV0udmFsdWVzKCkpO1xuICAgIHBlbmRpbmdbMV0uY2xlYXIoKTtcbiAgICBjb25zdCBmdW5jdGlvbnMgPSBuZXcgU2V0KHBlbmRpbmdbMl0pO1xuICAgIHBlbmRpbmdbMl0uY2xlYXIoKTtcbiAgICBhdG9tU3RhdGVzLmZvckVhY2goKGF0b21TdGF0ZSkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgcmV0dXJuIChfYSA9IGF0b21TdGF0ZS5tKSA9PSBudWxsID8gdm9pZCAwIDogX2EubC5mb3JFYWNoKChsKSA9PiBsKCkpO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9ucy5mb3JFYWNoKChmbikgPT4gZm4oKSk7XG4gIH1cbn07XG5jb25zdCBjcmVhdGVTdG9yZSA9ICgpID0+IHtcbiAgY29uc3QgYXRvbVN0YXRlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gIGxldCBkZWJ1Z01vdW50ZWRBdG9tcztcbiAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgZGVidWdNb3VudGVkQXRvbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICB9XG4gIGNvbnN0IGdldEF0b21TdGF0ZSA9IChhdG9tKSA9PiB7XG4gICAgbGV0IGF0b21TdGF0ZSA9IGF0b21TdGF0ZU1hcC5nZXQoYXRvbSk7XG4gICAgaWYgKCFhdG9tU3RhdGUpIHtcbiAgICAgIGF0b21TdGF0ZSA9IHsgZDogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgcDogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSwgbjogMCB9O1xuICAgICAgYXRvbVN0YXRlTWFwLnNldChhdG9tLCBhdG9tU3RhdGUpO1xuICAgIH1cbiAgICByZXR1cm4gYXRvbVN0YXRlO1xuICB9O1xuICBjb25zdCBzZXRBdG9tU3RhdGVWYWx1ZU9yUHJvbWlzZSA9IChhdG9tLCBhdG9tU3RhdGUsIHZhbHVlT3JQcm9taXNlLCBhYm9ydFByb21pc2UgPSAoKSA9PiB7XG4gIH0sIGNvbXBsZXRlUHJvbWlzZSA9ICgpID0+IHtcbiAgfSkgPT4ge1xuICAgIGNvbnN0IGhhc1ByZXZWYWx1ZSA9IFwidlwiIGluIGF0b21TdGF0ZTtcbiAgICBjb25zdCBwcmV2VmFsdWUgPSBhdG9tU3RhdGUudjtcbiAgICBjb25zdCBwZW5kaW5nUHJvbWlzZSA9IGdldFBlbmRpbmdDb250aW51YWJsZVByb21pc2UoYXRvbVN0YXRlKTtcbiAgICBpZiAoaXNQcm9taXNlTGlrZSh2YWx1ZU9yUHJvbWlzZSkpIHtcbiAgICAgIGlmIChwZW5kaW5nUHJvbWlzZSkge1xuICAgICAgICBpZiAocGVuZGluZ1Byb21pc2UgIT09IHZhbHVlT3JQcm9taXNlKSB7XG4gICAgICAgICAgcGVuZGluZ1Byb21pc2VbQ09OVElOVUVfUFJPTUlTRV0odmFsdWVPclByb21pc2UsIGFib3J0UHJvbWlzZSk7XG4gICAgICAgICAgKythdG9tU3RhdGUubjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY29udGludWFibGVQcm9taXNlID0gY3JlYXRlQ29udGludWFibGVQcm9taXNlKFxuICAgICAgICAgIHZhbHVlT3JQcm9taXNlLFxuICAgICAgICAgIGFib3J0UHJvbWlzZSxcbiAgICAgICAgICBjb21wbGV0ZVByb21pc2VcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGNvbnRpbnVhYmxlUHJvbWlzZS5zdGF0dXMgPT09IFBFTkRJTkcpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGEgb2YgYXRvbVN0YXRlLmQua2V5cygpKSB7XG4gICAgICAgICAgICBjb25zdCBhU3RhdGUgPSBnZXRBdG9tU3RhdGUoYSk7XG4gICAgICAgICAgICBhZGRQZW5kaW5nQ29udGludWFibGVQcm9taXNlVG9EZXBlbmRlbmN5KFxuICAgICAgICAgICAgICBhdG9tLFxuICAgICAgICAgICAgICBjb250aW51YWJsZVByb21pc2UsXG4gICAgICAgICAgICAgIGFTdGF0ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXRvbVN0YXRlLnYgPSBjb250aW51YWJsZVByb21pc2U7XG4gICAgICAgIGRlbGV0ZSBhdG9tU3RhdGUuZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHBlbmRpbmdQcm9taXNlKSB7XG4gICAgICAgIHBlbmRpbmdQcm9taXNlW0NPTlRJTlVFX1BST01JU0VdKFxuICAgICAgICAgIFByb21pc2UucmVzb2x2ZSh2YWx1ZU9yUHJvbWlzZSksXG4gICAgICAgICAgYWJvcnRQcm9taXNlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBhdG9tU3RhdGUudiA9IHZhbHVlT3JQcm9taXNlO1xuICAgICAgZGVsZXRlIGF0b21TdGF0ZS5lO1xuICAgIH1cbiAgICBpZiAoIWhhc1ByZXZWYWx1ZSB8fCAhT2JqZWN0LmlzKHByZXZWYWx1ZSwgYXRvbVN0YXRlLnYpKSB7XG4gICAgICArK2F0b21TdGF0ZS5uO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgYWRkRGVwZW5kZW5jeSA9IChwZW5kaW5nLCBhdG9tLCBhLCBhU3RhdGUpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiICYmIGEgPT09IGF0b20pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIltCdWddIGF0b20gY2Fubm90IGRlcGVuZCBvbiBpdHNlbGZcIik7XG4gICAgfVxuICAgIGNvbnN0IGF0b21TdGF0ZSA9IGdldEF0b21TdGF0ZShhdG9tKTtcbiAgICBhdG9tU3RhdGUuZC5zZXQoYSwgYVN0YXRlLm4pO1xuICAgIGNvbnN0IGNvbnRpbnVhYmxlUHJvbWlzZSA9IGdldFBlbmRpbmdDb250aW51YWJsZVByb21pc2UoYXRvbVN0YXRlKTtcbiAgICBpZiAoY29udGludWFibGVQcm9taXNlKSB7XG4gICAgICBhZGRQZW5kaW5nQ29udGludWFibGVQcm9taXNlVG9EZXBlbmRlbmN5KGF0b20sIGNvbnRpbnVhYmxlUHJvbWlzZSwgYVN0YXRlKTtcbiAgICB9XG4gICAgKF9hID0gYVN0YXRlLm0pID09IG51bGwgPyB2b2lkIDAgOiBfYS50LmFkZChhdG9tKTtcbiAgICBpZiAocGVuZGluZykge1xuICAgICAgYWRkUGVuZGluZ0RlcGVuZGVudChwZW5kaW5nLCBhLCBhdG9tKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHJlYWRBdG9tU3RhdGUgPSAocGVuZGluZywgYXRvbSwgZm9yY2UpID0+IHtcbiAgICBjb25zdCBhdG9tU3RhdGUgPSBnZXRBdG9tU3RhdGUoYXRvbSk7XG4gICAgaWYgKCEoZm9yY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGZvcmNlKGF0b20pKSAmJiBpc0F0b21TdGF0ZUluaXRpYWxpemVkKGF0b21TdGF0ZSkpIHtcbiAgICAgIGlmIChhdG9tU3RhdGUubSkge1xuICAgICAgICByZXR1cm4gYXRvbVN0YXRlO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmZyb20oYXRvbVN0YXRlLmQpLmV2ZXJ5KFxuICAgICAgICAoW2EsIG5dKSA9PiAoXG4gICAgICAgICAgLy8gUmVjdXJzaXZlbHksIHJlYWQgdGhlIGF0b20gc3RhdGUgb2YgdGhlIGRlcGVuZGVuY3ksIGFuZFxuICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBhdG9tIGVwb2NoIG51bWJlciBpcyB1bmNoYW5nZWRcbiAgICAgICAgICByZWFkQXRvbVN0YXRlKHBlbmRpbmcsIGEsIGZvcmNlKS5uID09PSBuXG4gICAgICAgIClcbiAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuIGF0b21TdGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXRvbVN0YXRlLmQuY2xlYXIoKTtcbiAgICBsZXQgaXNTeW5jID0gdHJ1ZTtcbiAgICBjb25zdCBnZXR0ZXIgPSAoYSkgPT4ge1xuICAgICAgaWYgKGlzU2VsZkF0b20oYXRvbSwgYSkpIHtcbiAgICAgICAgY29uc3QgYVN0YXRlMiA9IGdldEF0b21TdGF0ZShhKTtcbiAgICAgICAgaWYgKCFpc0F0b21TdGF0ZUluaXRpYWxpemVkKGFTdGF0ZTIpKSB7XG4gICAgICAgICAgaWYgKGhhc0luaXRpYWxWYWx1ZShhKSkge1xuICAgICAgICAgICAgc2V0QXRvbVN0YXRlVmFsdWVPclByb21pc2UoYSwgYVN0YXRlMiwgYS5pbml0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gYXRvbSBpbml0XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0dXJuQXRvbVZhbHVlKGFTdGF0ZTIpO1xuICAgICAgfVxuICAgICAgY29uc3QgYVN0YXRlID0gcmVhZEF0b21TdGF0ZShwZW5kaW5nLCBhLCBmb3JjZSk7XG4gICAgICBpZiAoaXNTeW5jKSB7XG4gICAgICAgIGFkZERlcGVuZGVuY3kocGVuZGluZywgYXRvbSwgYSwgYVN0YXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHBlbmRpbmcyID0gY3JlYXRlUGVuZGluZygpO1xuICAgICAgICBhZGREZXBlbmRlbmN5KHBlbmRpbmcyLCBhdG9tLCBhLCBhU3RhdGUpO1xuICAgICAgICBtb3VudERlcGVuZGVuY2llcyhwZW5kaW5nMiwgYXRvbSwgYXRvbVN0YXRlKTtcbiAgICAgICAgZmx1c2hQZW5kaW5nKHBlbmRpbmcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXR1cm5BdG9tVmFsdWUoYVN0YXRlKTtcbiAgICB9O1xuICAgIGxldCBjb250cm9sbGVyO1xuICAgIGxldCBzZXRTZWxmO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBnZXQgc2lnbmFsKCkge1xuICAgICAgICBpZiAoIWNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250cm9sbGVyLnNpZ25hbDtcbiAgICAgIH0sXG4gICAgICBnZXQgc2V0U2VsZigpIHtcbiAgICAgICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiICYmICFpc0FjdHVhbGx5V3JpdGFibGVBdG9tKGF0b20pKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwic2V0U2VsZiBmdW5jdGlvbiBjYW5ub3QgYmUgdXNlZCB3aXRoIHJlYWQtb25seSBhdG9tXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2V0U2VsZiAmJiBpc0FjdHVhbGx5V3JpdGFibGVBdG9tKGF0b20pKSB7XG4gICAgICAgICAgc2V0U2VsZiA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgaXNTeW5jKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihcInNldFNlbGYgZnVuY3Rpb24gY2Fubm90IGJlIGNhbGxlZCBpbiBzeW5jXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc1N5bmMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHdyaXRlQXRvbShhdG9tLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXRTZWxmO1xuICAgICAgfVxuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHZhbHVlT3JQcm9taXNlID0gYXRvbS5yZWFkKGdldHRlciwgb3B0aW9ucyk7XG4gICAgICBzZXRBdG9tU3RhdGVWYWx1ZU9yUHJvbWlzZShcbiAgICAgICAgYXRvbSxcbiAgICAgICAgYXRvbVN0YXRlLFxuICAgICAgICB2YWx1ZU9yUHJvbWlzZSxcbiAgICAgICAgKCkgPT4gY29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogY29udHJvbGxlci5hYm9ydCgpLFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgaWYgKGF0b21TdGF0ZS5tKSB7XG4gICAgICAgICAgICBjb25zdCBwZW5kaW5nMiA9IGNyZWF0ZVBlbmRpbmcoKTtcbiAgICAgICAgICAgIG1vdW50RGVwZW5kZW5jaWVzKHBlbmRpbmcyLCBhdG9tLCBhdG9tU3RhdGUpO1xuICAgICAgICAgICAgZmx1c2hQZW5kaW5nKHBlbmRpbmcyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICByZXR1cm4gYXRvbVN0YXRlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBkZWxldGUgYXRvbVN0YXRlLnY7XG4gICAgICBhdG9tU3RhdGUuZSA9IGVycm9yO1xuICAgICAgKythdG9tU3RhdGUubjtcbiAgICAgIHJldHVybiBhdG9tU3RhdGU7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlzU3luYyA9IGZhbHNlO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcmVhZEF0b20gPSAoYXRvbSkgPT4gcmV0dXJuQXRvbVZhbHVlKHJlYWRBdG9tU3RhdGUodm9pZCAwLCBhdG9tKSk7XG4gIGNvbnN0IHJlY29tcHV0ZURlcGVuZGVudHMgPSAocGVuZGluZywgYXRvbSkgPT4ge1xuICAgIGNvbnN0IGdldERlcGVuZGVudHMgPSAoYSkgPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGNvbnN0IGFTdGF0ZSA9IGdldEF0b21TdGF0ZShhKTtcbiAgICAgIGNvbnN0IGRlcGVuZGVudHMgPSBuZXcgU2V0KChfYSA9IGFTdGF0ZS5tKSA9PSBudWxsID8gdm9pZCAwIDogX2EudCk7XG4gICAgICBmb3IgKGNvbnN0IGF0b21XaXRoUGVuZGluZ0NvbnRpbnVhYmxlUHJvbWlzZSBvZiBhU3RhdGUucCkge1xuICAgICAgICBkZXBlbmRlbnRzLmFkZChhdG9tV2l0aFBlbmRpbmdDb250aW51YWJsZVByb21pc2UpO1xuICAgICAgfVxuICAgICAgKF9iID0gZ2V0UGVuZGluZ0RlcGVuZGVudHMocGVuZGluZywgYSkpID09IG51bGwgPyB2b2lkIDAgOiBfYi5mb3JFYWNoKChkZXBlbmRlbnQpID0+IHtcbiAgICAgICAgZGVwZW5kZW50cy5hZGQoZGVwZW5kZW50KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGRlcGVuZGVudHM7XG4gICAgfTtcbiAgICBjb25zdCB0b3Bzb3J0ZWRBdG9tcyA9IFtdO1xuICAgIGNvbnN0IG1hcmtlZEF0b21zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb25zdCB2aXNpdCA9IChuKSA9PiB7XG4gICAgICBpZiAobWFya2VkQXRvbXMuaGFzKG4pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG1hcmtlZEF0b21zLmFkZChuKTtcbiAgICAgIGZvciAoY29uc3QgbSBvZiBnZXREZXBlbmRlbnRzKG4pKSB7XG4gICAgICAgIGlmIChuICE9PSBtKSB7XG4gICAgICAgICAgdmlzaXQobSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRvcHNvcnRlZEF0b21zLnB1c2gobik7XG4gICAgfTtcbiAgICB2aXNpdChhdG9tKTtcbiAgICBjb25zdCBjaGFuZ2VkQXRvbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbYXRvbV0pO1xuICAgIGNvbnN0IGlzTWFya2VkID0gKGEpID0+IG1hcmtlZEF0b21zLmhhcyhhKTtcbiAgICBmb3IgKGxldCBpID0gdG9wc29ydGVkQXRvbXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGNvbnN0IGEgPSB0b3Bzb3J0ZWRBdG9tc1tpXTtcbiAgICAgIGNvbnN0IGFTdGF0ZSA9IGdldEF0b21TdGF0ZShhKTtcbiAgICAgIGNvbnN0IHByZXZFcG9jaE51bWJlciA9IGFTdGF0ZS5uO1xuICAgICAgbGV0IGhhc0NoYW5nZWREZXBzID0gZmFsc2U7XG4gICAgICBmb3IgKGNvbnN0IGRlcCBvZiBhU3RhdGUuZC5rZXlzKCkpIHtcbiAgICAgICAgaWYgKGRlcCAhPT0gYSAmJiBjaGFuZ2VkQXRvbXMuaGFzKGRlcCkpIHtcbiAgICAgICAgICBoYXNDaGFuZ2VkRGVwcyA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChoYXNDaGFuZ2VkRGVwcykge1xuICAgICAgICByZWFkQXRvbVN0YXRlKHBlbmRpbmcsIGEsIGlzTWFya2VkKTtcbiAgICAgICAgbW91bnREZXBlbmRlbmNpZXMocGVuZGluZywgYSwgYVN0YXRlKTtcbiAgICAgICAgaWYgKHByZXZFcG9jaE51bWJlciAhPT0gYVN0YXRlLm4pIHtcbiAgICAgICAgICBhZGRQZW5kaW5nQXRvbShwZW5kaW5nLCBhLCBhU3RhdGUpO1xuICAgICAgICAgIGNoYW5nZWRBdG9tcy5hZGQoYSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1hcmtlZEF0b21zLmRlbGV0ZShhKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHdyaXRlQXRvbVN0YXRlID0gKHBlbmRpbmcsIGF0b20sIC4uLmFyZ3MpID0+IHtcbiAgICBjb25zdCBnZXR0ZXIgPSAoYSkgPT4gcmV0dXJuQXRvbVZhbHVlKHJlYWRBdG9tU3RhdGUocGVuZGluZywgYSkpO1xuICAgIGNvbnN0IHNldHRlciA9IChhLCAuLi5hcmdzMikgPT4ge1xuICAgICAgbGV0IHI7XG4gICAgICBpZiAoaXNTZWxmQXRvbShhdG9tLCBhKSkge1xuICAgICAgICBpZiAoIWhhc0luaXRpYWxWYWx1ZShhKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImF0b20gbm90IHdyaXRhYmxlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFTdGF0ZSA9IGdldEF0b21TdGF0ZShhKTtcbiAgICAgICAgY29uc3QgaGFzUHJldlZhbHVlID0gXCJ2XCIgaW4gYVN0YXRlO1xuICAgICAgICBjb25zdCBwcmV2VmFsdWUgPSBhU3RhdGUudjtcbiAgICAgICAgY29uc3QgdiA9IGFyZ3MyWzBdO1xuICAgICAgICBzZXRBdG9tU3RhdGVWYWx1ZU9yUHJvbWlzZShhLCBhU3RhdGUsIHYpO1xuICAgICAgICBtb3VudERlcGVuZGVuY2llcyhwZW5kaW5nLCBhLCBhU3RhdGUpO1xuICAgICAgICBpZiAoIWhhc1ByZXZWYWx1ZSB8fCAhT2JqZWN0LmlzKHByZXZWYWx1ZSwgYVN0YXRlLnYpKSB7XG4gICAgICAgICAgYWRkUGVuZGluZ0F0b20ocGVuZGluZywgYSwgYVN0YXRlKTtcbiAgICAgICAgICByZWNvbXB1dGVEZXBlbmRlbnRzKHBlbmRpbmcsIGEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByID0gd3JpdGVBdG9tU3RhdGUocGVuZGluZywgYSwgLi4uYXJnczIpO1xuICAgICAgfVxuICAgICAgZmx1c2hQZW5kaW5nKHBlbmRpbmcpO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICBjb25zdCByZXN1bHQgPSBhdG9tLndyaXRlKGdldHRlciwgc2V0dGVyLCAuLi5hcmdzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBjb25zdCB3cml0ZUF0b20gPSAoYXRvbSwgLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IHBlbmRpbmcgPSBjcmVhdGVQZW5kaW5nKCk7XG4gICAgY29uc3QgcmVzdWx0ID0gd3JpdGVBdG9tU3RhdGUocGVuZGluZywgYXRvbSwgLi4uYXJncyk7XG4gICAgZmx1c2hQZW5kaW5nKHBlbmRpbmcpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIGNvbnN0IG1vdW50RGVwZW5kZW5jaWVzID0gKHBlbmRpbmcsIGF0b20sIGF0b21TdGF0ZSkgPT4ge1xuICAgIGlmIChhdG9tU3RhdGUubSAmJiAhZ2V0UGVuZGluZ0NvbnRpbnVhYmxlUHJvbWlzZShhdG9tU3RhdGUpKSB7XG4gICAgICBmb3IgKGNvbnN0IGEgb2YgYXRvbVN0YXRlLmQua2V5cygpKSB7XG4gICAgICAgIGlmICghYXRvbVN0YXRlLm0uZC5oYXMoYSkpIHtcbiAgICAgICAgICBjb25zdCBhTW91bnRlZCA9IG1vdW50QXRvbShwZW5kaW5nLCBhKTtcbiAgICAgICAgICBhTW91bnRlZC50LmFkZChhdG9tKTtcbiAgICAgICAgICBhdG9tU3RhdGUubS5kLmFkZChhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBhIG9mIGF0b21TdGF0ZS5tLmQgfHwgW10pIHtcbiAgICAgICAgaWYgKCFhdG9tU3RhdGUuZC5oYXMoYSkpIHtcbiAgICAgICAgICBhdG9tU3RhdGUubS5kLmRlbGV0ZShhKTtcbiAgICAgICAgICBjb25zdCBhTW91bnRlZCA9IHVubW91bnRBdG9tKHBlbmRpbmcsIGEpO1xuICAgICAgICAgIGFNb3VudGVkID09IG51bGwgPyB2b2lkIDAgOiBhTW91bnRlZC50LmRlbGV0ZShhdG9tKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgbW91bnRBdG9tID0gKHBlbmRpbmcsIGF0b20pID0+IHtcbiAgICBjb25zdCBhdG9tU3RhdGUgPSBnZXRBdG9tU3RhdGUoYXRvbSk7XG4gICAgaWYgKCFhdG9tU3RhdGUubSkge1xuICAgICAgcmVhZEF0b21TdGF0ZShwZW5kaW5nLCBhdG9tKTtcbiAgICAgIGZvciAoY29uc3QgYSBvZiBhdG9tU3RhdGUuZC5rZXlzKCkpIHtcbiAgICAgICAgY29uc3QgYU1vdW50ZWQgPSBtb3VudEF0b20ocGVuZGluZywgYSk7XG4gICAgICAgIGFNb3VudGVkLnQuYWRkKGF0b20pO1xuICAgICAgfVxuICAgICAgYXRvbVN0YXRlLm0gPSB7XG4gICAgICAgIGw6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksXG4gICAgICAgIGQ6IG5ldyBTZXQoYXRvbVN0YXRlLmQua2V5cygpKSxcbiAgICAgICAgdDogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKVxuICAgICAgfTtcbiAgICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBkZWJ1Z01vdW50ZWRBdG9tcy5hZGQoYXRvbSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNBY3R1YWxseVdyaXRhYmxlQXRvbShhdG9tKSAmJiBhdG9tLm9uTW91bnQpIHtcbiAgICAgICAgY29uc3QgbW91bnRlZCA9IGF0b21TdGF0ZS5tO1xuICAgICAgICBjb25zdCB7IG9uTW91bnQgfSA9IGF0b207XG4gICAgICAgIGFkZFBlbmRpbmdGdW5jdGlvbihwZW5kaW5nLCAoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgb25Vbm1vdW50ID0gb25Nb3VudChcbiAgICAgICAgICAgICguLi5hcmdzKSA9PiB3cml0ZUF0b21TdGF0ZShwZW5kaW5nLCBhdG9tLCAuLi5hcmdzKVxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKG9uVW5tb3VudCkge1xuICAgICAgICAgICAgbW91bnRlZC51ID0gb25Vbm1vdW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhdG9tU3RhdGUubTtcbiAgfTtcbiAgY29uc3QgdW5tb3VudEF0b20gPSAocGVuZGluZywgYXRvbSkgPT4ge1xuICAgIGNvbnN0IGF0b21TdGF0ZSA9IGdldEF0b21TdGF0ZShhdG9tKTtcbiAgICBpZiAoYXRvbVN0YXRlLm0gJiYgIWF0b21TdGF0ZS5tLmwuc2l6ZSAmJiAhQXJyYXkuZnJvbShhdG9tU3RhdGUubS50KS5zb21lKChhKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICByZXR1cm4gKF9hID0gZ2V0QXRvbVN0YXRlKGEpLm0pID09IG51bGwgPyB2b2lkIDAgOiBfYS5kLmhhcyhhdG9tKTtcbiAgICB9KSkge1xuICAgICAgY29uc3Qgb25Vbm1vdW50ID0gYXRvbVN0YXRlLm0udTtcbiAgICAgIGlmIChvblVubW91bnQpIHtcbiAgICAgICAgYWRkUGVuZGluZ0Z1bmN0aW9uKHBlbmRpbmcsIG9uVW5tb3VudCk7XG4gICAgICB9XG4gICAgICBkZWxldGUgYXRvbVN0YXRlLm07XG4gICAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgZGVidWdNb3VudGVkQXRvbXMuZGVsZXRlKGF0b20pO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBhIG9mIGF0b21TdGF0ZS5kLmtleXMoKSkge1xuICAgICAgICBjb25zdCBhTW91bnRlZCA9IHVubW91bnRBdG9tKHBlbmRpbmcsIGEpO1xuICAgICAgICBhTW91bnRlZCA9PSBudWxsID8gdm9pZCAwIDogYU1vdW50ZWQudC5kZWxldGUoYXRvbSk7XG4gICAgICB9XG4gICAgICBjb25zdCBwZW5kaW5nUHJvbWlzZSA9IGdldFBlbmRpbmdDb250aW51YWJsZVByb21pc2UoYXRvbVN0YXRlKTtcbiAgICAgIGlmIChwZW5kaW5nUHJvbWlzZSkge1xuICAgICAgICBwZW5kaW5nUHJvbWlzZVtDT05USU5VRV9QUk9NSVNFXSh2b2lkIDAsICgpID0+IHtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gYXRvbVN0YXRlLm07XG4gIH07XG4gIGNvbnN0IHN1YnNjcmliZUF0b20gPSAoYXRvbSwgbGlzdGVuZXIpID0+IHtcbiAgICBjb25zdCBwZW5kaW5nID0gY3JlYXRlUGVuZGluZygpO1xuICAgIGNvbnN0IG1vdW50ZWQgPSBtb3VudEF0b20ocGVuZGluZywgYXRvbSk7XG4gICAgZmx1c2hQZW5kaW5nKHBlbmRpbmcpO1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IG1vdW50ZWQubDtcbiAgICBsaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgICBjb25zdCBwZW5kaW5nMiA9IGNyZWF0ZVBlbmRpbmcoKTtcbiAgICAgIHVubW91bnRBdG9tKHBlbmRpbmcyLCBhdG9tKTtcbiAgICAgIGZsdXNoUGVuZGluZyhwZW5kaW5nMik7XG4gICAgfTtcbiAgfTtcbiAgY29uc3Qgc3RvcmUgPSB7XG4gICAgZ2V0OiByZWFkQXRvbSxcbiAgICBzZXQ6IHdyaXRlQXRvbSxcbiAgICBzdWI6IHN1YnNjcmliZUF0b21cbiAgfTtcbiAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgY29uc3QgZGV2U3RvcmUgPSB7XG4gICAgICAvLyBzdG9yZSBkZXYgbWV0aG9kcyAodGhlc2UgYXJlIHRlbnRhdGl2ZSBhbmQgc3ViamVjdCB0byBjaGFuZ2Ugd2l0aG91dCBub3RpY2UpXG4gICAgICBkZXY0X2dldF9pbnRlcm5hbF93ZWFrX21hcDogKCkgPT4gYXRvbVN0YXRlTWFwLFxuICAgICAgZGV2NF9nZXRfbW91bnRlZF9hdG9tczogKCkgPT4gZGVidWdNb3VudGVkQXRvbXMsXG4gICAgICBkZXY0X3Jlc3RvcmVfYXRvbXM6ICh2YWx1ZXMpID0+IHtcbiAgICAgICAgY29uc3QgcGVuZGluZyA9IGNyZWF0ZVBlbmRpbmcoKTtcbiAgICAgICAgZm9yIChjb25zdCBbYXRvbSwgdmFsdWVdIG9mIHZhbHVlcykge1xuICAgICAgICAgIGlmIChoYXNJbml0aWFsVmFsdWUoYXRvbSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGF0b21TdGF0ZSA9IGdldEF0b21TdGF0ZShhdG9tKTtcbiAgICAgICAgICAgIGNvbnN0IGhhc1ByZXZWYWx1ZSA9IFwidlwiIGluIGF0b21TdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IHByZXZWYWx1ZSA9IGF0b21TdGF0ZS52O1xuICAgICAgICAgICAgc2V0QXRvbVN0YXRlVmFsdWVPclByb21pc2UoYXRvbSwgYXRvbVN0YXRlLCB2YWx1ZSk7XG4gICAgICAgICAgICBtb3VudERlcGVuZGVuY2llcyhwZW5kaW5nLCBhdG9tLCBhdG9tU3RhdGUpO1xuICAgICAgICAgICAgaWYgKCFoYXNQcmV2VmFsdWUgfHwgIU9iamVjdC5pcyhwcmV2VmFsdWUsIGF0b21TdGF0ZS52KSkge1xuICAgICAgICAgICAgICBhZGRQZW5kaW5nQXRvbShwZW5kaW5nLCBhdG9tLCBhdG9tU3RhdGUpO1xuICAgICAgICAgICAgICByZWNvbXB1dGVEZXBlbmRlbnRzKHBlbmRpbmcsIGF0b20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmbHVzaFBlbmRpbmcocGVuZGluZyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuYXNzaWduKHN0b3JlLCBkZXZTdG9yZSk7XG4gIH1cbiAgcmV0dXJuIHN0b3JlO1xufTtcbmxldCBkZWZhdWx0U3RvcmU7XG5jb25zdCBnZXREZWZhdWx0U3RvcmUgPSAoKSA9PiB7XG4gIGlmICghZGVmYXVsdFN0b3JlKSB7XG4gICAgZGVmYXVsdFN0b3JlID0gY3JlYXRlU3RvcmUoKTtcbiAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGdsb2JhbFRoaXMuX19KT1RBSV9ERUZBVUxUX1NUT1JFX18gfHwgKGdsb2JhbFRoaXMuX19KT1RBSV9ERUZBVUxUX1NUT1JFX18gPSBkZWZhdWx0U3RvcmUpO1xuICAgICAgaWYgKGdsb2JhbFRoaXMuX19KT1RBSV9ERUZBVUxUX1NUT1JFX18gIT09IGRlZmF1bHRTdG9yZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJEZXRlY3RlZCBtdWx0aXBsZSBKb3RhaSBpbnN0YW5jZXMuIEl0IG1heSBjYXVzZSB1bmV4cGVjdGVkIGJlaGF2aW9yIHdpdGggdGhlIGRlZmF1bHQgc3RvcmUuIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvam90YWkvZGlzY3Vzc2lvbnMvMjA0NFwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWZhdWx0U3RvcmU7XG59O1xuXG5leHBvcnQgeyBhdG9tLCBjcmVhdGVTdG9yZSwgZ2V0RGVmYXVsdFN0b3JlIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jotai/esm/vanilla.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jotai/esm/vanilla/utils.mjs":
/*!**************************************************!*\
  !*** ./node_modules/jotai/esm/vanilla/utils.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RESET: () => (/* binding */ RESET),\n/* harmony export */   atomFamily: () => (/* binding */ atomFamily),\n/* harmony export */   atomWithDefault: () => (/* binding */ atomWithDefault),\n/* harmony export */   atomWithLazy: () => (/* binding */ atomWithLazy),\n/* harmony export */   atomWithObservable: () => (/* binding */ atomWithObservable),\n/* harmony export */   atomWithReducer: () => (/* binding */ atomWithReducer),\n/* harmony export */   atomWithRefresh: () => (/* binding */ atomWithRefresh),\n/* harmony export */   atomWithReset: () => (/* binding */ atomWithReset),\n/* harmony export */   atomWithStorage: () => (/* binding */ atomWithStorage),\n/* harmony export */   createJSONStorage: () => (/* binding */ createJSONStorage),\n/* harmony export */   freezeAtom: () => (/* binding */ freezeAtom),\n/* harmony export */   freezeAtomCreator: () => (/* binding */ freezeAtomCreator),\n/* harmony export */   loadable: () => (/* binding */ loadable),\n/* harmony export */   selectAtom: () => (/* binding */ selectAtom),\n/* harmony export */   splitAtom: () => (/* binding */ splitAtom),\n/* harmony export */   unstable_withStorageValidator: () => (/* binding */ withStorageValidator),\n/* harmony export */   unwrap: () => (/* binding */ unwrap)\n/* harmony export */ });\n/* harmony import */ var jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jotai/vanilla */ \"(ssr)/./node_modules/jotai/esm/vanilla.mjs\");\n\n\nconst RESET = Symbol(\n  ( false ? 0 : void 0) !== \"production\" ? \"RESET\" : \"\"\n);\n\nfunction atomWithReset(initialValue) {\n  const anAtom = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)(\n    initialValue,\n    (get, set, update) => {\n      const nextValue = typeof update === \"function\" ? update(get(anAtom)) : update;\n      set(anAtom, nextValue === RESET ? initialValue : nextValue);\n    }\n  );\n  return anAtom;\n}\n\nfunction atomWithReducer(initialValue, reducer) {\n  return (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)(initialValue, function(get, set, action) {\n    set(this, reducer(get(this), action));\n  });\n}\n\nfunction atomFamily(initializeAtom, areEqual) {\n  let shouldRemove = null;\n  const atoms = /* @__PURE__ */ new Map();\n  const createAtom = (param) => {\n    let item;\n    if (areEqual === void 0) {\n      item = atoms.get(param);\n    } else {\n      for (const [key, value] of atoms) {\n        if (areEqual(key, param)) {\n          item = value;\n          break;\n        }\n      }\n    }\n    if (item !== void 0) {\n      if (shouldRemove == null ? void 0 : shouldRemove(item[1], param)) {\n        createAtom.remove(param);\n      } else {\n        return item[0];\n      }\n    }\n    const newAtom = initializeAtom(param);\n    atoms.set(param, [newAtom, Date.now()]);\n    return newAtom;\n  };\n  createAtom.remove = (param) => {\n    if (areEqual === void 0) {\n      atoms.delete(param);\n    } else {\n      for (const [key] of atoms) {\n        if (areEqual(key, param)) {\n          atoms.delete(key);\n          break;\n        }\n      }\n    }\n  };\n  createAtom.setShouldRemove = (fn) => {\n    shouldRemove = fn;\n    if (!shouldRemove) return;\n    for (const [key, value] of atoms) {\n      if (shouldRemove(value[1], key)) {\n        atoms.delete(key);\n      }\n    }\n  };\n  return createAtom;\n}\n\nconst getCached$2 = (c, m, k) => (m.has(k) ? m : m.set(k, c())).get(k);\nconst cache1$3 = /* @__PURE__ */ new WeakMap();\nconst memo3 = (create, dep1, dep2, dep3) => {\n  const cache2 = getCached$2(() => /* @__PURE__ */ new WeakMap(), cache1$3, dep1);\n  const cache3 = getCached$2(() => /* @__PURE__ */ new WeakMap(), cache2, dep2);\n  return getCached$2(create, cache3, dep3);\n};\nfunction selectAtom(anAtom, selector, equalityFn = Object.is) {\n  return memo3(\n    () => {\n      const EMPTY = Symbol();\n      const selectValue = ([value, prevSlice]) => {\n        if (prevSlice === EMPTY) {\n          return selector(value);\n        }\n        const slice = selector(value, prevSlice);\n        return equalityFn(prevSlice, slice) ? prevSlice : slice;\n      };\n      const derivedAtom = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)((get) => {\n        const prev = get(derivedAtom);\n        const value = get(anAtom);\n        return selectValue([value, prev]);\n      });\n      derivedAtom.init = EMPTY;\n      return derivedAtom;\n    },\n    anAtom,\n    selector,\n    equalityFn\n  );\n}\n\nconst frozenAtoms = /* @__PURE__ */ new WeakSet();\nconst deepFreeze = (obj) => {\n  if (typeof obj !== \"object\" || obj === null) return;\n  Object.freeze(obj);\n  const propNames = Object.getOwnPropertyNames(obj);\n  for (const name of propNames) {\n    const value = obj[name];\n    deepFreeze(value);\n  }\n  return obj;\n};\nfunction freezeAtom(anAtom) {\n  if (frozenAtoms.has(anAtom)) {\n    return anAtom;\n  }\n  frozenAtoms.add(anAtom);\n  const origRead = anAtom.read;\n  anAtom.read = function(get, options) {\n    return deepFreeze(origRead.call(this, get, options));\n  };\n  if (\"write\" in anAtom) {\n    const origWrite = anAtom.write;\n    anAtom.write = function(get, set, ...args) {\n      return origWrite.call(\n        this,\n        get,\n        (...setArgs) => {\n          if (setArgs[0] === anAtom) {\n            setArgs[1] = deepFreeze(setArgs[1]);\n          }\n          return set(...setArgs);\n        },\n        ...args\n      );\n    };\n  }\n  return anAtom;\n}\nfunction freezeAtomCreator(createAtom) {\n  if (( false ? 0 : void 0) !== \"production\") {\n    console.warn(\n      \"[DEPRECATED] freezeAtomCreator is deprecated, define it on users end\"\n    );\n  }\n  return (...args) => freezeAtom(createAtom(...args));\n}\n\nconst getCached$1 = (c, m, k) => (m.has(k) ? m : m.set(k, c())).get(k);\nconst cache1$2 = /* @__PURE__ */ new WeakMap();\nconst memo2$1 = (create, dep1, dep2) => {\n  const cache2 = getCached$1(() => /* @__PURE__ */ new WeakMap(), cache1$2, dep1);\n  return getCached$1(create, cache2, dep2);\n};\nconst cacheKeyForEmptyKeyExtractor = {};\nconst isWritable = (atom2) => !!atom2.write;\nconst isFunction = (x) => typeof x === \"function\";\nfunction splitAtom(arrAtom, keyExtractor) {\n  return memo2$1(\n    () => {\n      const mappingCache = /* @__PURE__ */ new WeakMap();\n      const getMapping = (arr, prev) => {\n        let mapping = mappingCache.get(arr);\n        if (mapping) {\n          return mapping;\n        }\n        const prevMapping = prev && mappingCache.get(prev);\n        const atomList = [];\n        const keyList = [];\n        arr.forEach((item, index) => {\n          const key = keyExtractor ? keyExtractor(item) : index;\n          keyList[index] = key;\n          const cachedAtom = prevMapping && prevMapping.atomList[prevMapping.keyList.indexOf(key)];\n          if (cachedAtom) {\n            atomList[index] = cachedAtom;\n            return;\n          }\n          const read = (get) => {\n            const prev2 = get(mappingAtom);\n            const currArr = get(arrAtom);\n            const mapping2 = getMapping(currArr, prev2 == null ? void 0 : prev2.arr);\n            const index2 = mapping2.keyList.indexOf(key);\n            if (index2 < 0 || index2 >= currArr.length) {\n              const prevItem = arr[getMapping(arr).keyList.indexOf(key)];\n              if (prevItem) {\n                return prevItem;\n              }\n              throw new Error(\"splitAtom: index out of bounds for read\");\n            }\n            return currArr[index2];\n          };\n          const write = (get, set, update) => {\n            const prev2 = get(mappingAtom);\n            const arr2 = get(arrAtom);\n            const mapping2 = getMapping(arr2, prev2 == null ? void 0 : prev2.arr);\n            const index2 = mapping2.keyList.indexOf(key);\n            if (index2 < 0 || index2 >= arr2.length) {\n              throw new Error(\"splitAtom: index out of bounds for write\");\n            }\n            const nextItem = isFunction(update) ? update(arr2[index2]) : update;\n            if (!Object.is(arr2[index2], nextItem)) {\n              set(arrAtom, [\n                ...arr2.slice(0, index2),\n                nextItem,\n                ...arr2.slice(index2 + 1)\n              ]);\n            }\n          };\n          atomList[index] = isWritable(arrAtom) ? (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)(read, write) : (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)(read);\n        });\n        if (prevMapping && prevMapping.keyList.length === keyList.length && prevMapping.keyList.every((x, i) => x === keyList[i])) {\n          mapping = prevMapping;\n        } else {\n          mapping = { arr, atomList, keyList };\n        }\n        mappingCache.set(arr, mapping);\n        return mapping;\n      };\n      const mappingAtom = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)((get) => {\n        const prev = get(mappingAtom);\n        const arr = get(arrAtom);\n        const mapping = getMapping(arr, prev == null ? void 0 : prev.arr);\n        return mapping;\n      });\n      if (( false ? 0 : void 0) !== \"production\") {\n        mappingAtom.debugPrivate = true;\n      }\n      mappingAtom.init = void 0;\n      const splittedAtom = isWritable(arrAtom) ? (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)(\n        (get) => get(mappingAtom).atomList,\n        (get, set, action) => {\n          switch (action.type) {\n            case \"remove\": {\n              const index = get(splittedAtom).indexOf(action.atom);\n              if (index >= 0) {\n                const arr = get(arrAtom);\n                set(arrAtom, [\n                  ...arr.slice(0, index),\n                  ...arr.slice(index + 1)\n                ]);\n              }\n              break;\n            }\n            case \"insert\": {\n              const index = action.before ? get(splittedAtom).indexOf(action.before) : get(splittedAtom).length;\n              if (index >= 0) {\n                const arr = get(arrAtom);\n                set(arrAtom, [\n                  ...arr.slice(0, index),\n                  action.value,\n                  ...arr.slice(index)\n                ]);\n              }\n              break;\n            }\n            case \"move\": {\n              const index1 = get(splittedAtom).indexOf(action.atom);\n              const index2 = action.before ? get(splittedAtom).indexOf(action.before) : get(splittedAtom).length;\n              if (index1 >= 0 && index2 >= 0) {\n                const arr = get(arrAtom);\n                if (index1 < index2) {\n                  set(arrAtom, [\n                    ...arr.slice(0, index1),\n                    ...arr.slice(index1 + 1, index2),\n                    arr[index1],\n                    ...arr.slice(index2)\n                  ]);\n                } else {\n                  set(arrAtom, [\n                    ...arr.slice(0, index2),\n                    arr[index1],\n                    ...arr.slice(index2, index1),\n                    ...arr.slice(index1 + 1)\n                  ]);\n                }\n              }\n              break;\n            }\n          }\n        }\n      ) : (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)((get) => get(mappingAtom).atomList);\n      return splittedAtom;\n    },\n    arrAtom,\n    keyExtractor || cacheKeyForEmptyKeyExtractor\n  );\n}\n\nfunction atomWithDefault(getDefault) {\n  const EMPTY = Symbol();\n  const overwrittenAtom = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)(EMPTY);\n  if (( false ? 0 : void 0) !== \"production\") {\n    overwrittenAtom.debugPrivate = true;\n  }\n  const anAtom = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)(\n    (get, options) => {\n      const overwritten = get(overwrittenAtom);\n      if (overwritten !== EMPTY) {\n        return overwritten;\n      }\n      return getDefault(get, options);\n    },\n    (get, set, update) => {\n      if (update === RESET) {\n        set(overwrittenAtom, EMPTY);\n      } else if (typeof update === \"function\") {\n        const prevValue = get(anAtom);\n        set(overwrittenAtom, update(prevValue));\n      } else {\n        set(overwrittenAtom, update);\n      }\n    }\n  );\n  return anAtom;\n}\n\nconst isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nfunction withStorageValidator(validator) {\n  return (unknownStorage) => {\n    const storage = {\n      ...unknownStorage,\n      getItem: (key, initialValue) => {\n        const validate = (value2) => {\n          if (!validator(value2)) {\n            return initialValue;\n          }\n          return value2;\n        };\n        const value = unknownStorage.getItem(key, initialValue);\n        if (isPromiseLike(value)) {\n          return value.then(validate);\n        }\n        return validate(value);\n      }\n    };\n    return storage;\n  };\n}\nfunction createJSONStorage(getStringStorage = () => {\n  try {\n    return window.localStorage;\n  } catch (e) {\n    if (( false ? 0 : void 0) !== \"production\") {\n      if (typeof window !== \"undefined\") {\n        console.warn(e);\n      }\n    }\n    return void 0;\n  }\n}, options) {\n  var _a;\n  let lastStr;\n  let lastValue;\n  const storage = {\n    getItem: (key, initialValue) => {\n      var _a2, _b;\n      const parse = (str2) => {\n        str2 = str2 || \"\";\n        if (lastStr !== str2) {\n          try {\n            lastValue = JSON.parse(str2, options == null ? void 0 : options.reviver);\n          } catch (e) {\n            return initialValue;\n          }\n          lastStr = str2;\n        }\n        return lastValue;\n      };\n      const str = (_b = (_a2 = getStringStorage()) == null ? void 0 : _a2.getItem(key)) != null ? _b : null;\n      if (isPromiseLike(str)) {\n        return str.then(parse);\n      }\n      return parse(str);\n    },\n    setItem: (key, newValue) => {\n      var _a2;\n      return (_a2 = getStringStorage()) == null ? void 0 : _a2.setItem(\n        key,\n        JSON.stringify(newValue, options == null ? void 0 : options.replacer)\n      );\n    },\n    removeItem: (key) => {\n      var _a2;\n      return (_a2 = getStringStorage()) == null ? void 0 : _a2.removeItem(key);\n    }\n  };\n  const createHandleSubscribe = (subscriber2) => (key, callback, initialValue) => subscriber2(key, (v) => {\n    let newValue;\n    try {\n      newValue = JSON.parse(v || \"\");\n    } catch (e) {\n      newValue = initialValue;\n    }\n    callback(newValue);\n  });\n  let subscriber;\n  try {\n    subscriber = (_a = getStringStorage()) == null ? void 0 : _a.subscribe;\n  } catch (e) {\n  }\n  if (!subscriber && typeof window !== \"undefined\" && typeof window.addEventListener === \"function\" && window.Storage) {\n    subscriber = (key, callback) => {\n      if (!(getStringStorage() instanceof window.Storage)) {\n        return () => {\n        };\n      }\n      const storageEventCallback = (e) => {\n        if (e.storageArea === getStringStorage() && e.key === key) {\n          callback(e.newValue);\n        }\n      };\n      window.addEventListener(\"storage\", storageEventCallback);\n      return () => {\n        window.removeEventListener(\"storage\", storageEventCallback);\n      };\n    };\n  }\n  if (subscriber) {\n    storage.subscribe = createHandleSubscribe(subscriber);\n  }\n  return storage;\n}\nconst defaultStorage = createJSONStorage();\nfunction atomWithStorage(key, initialValue, storage = defaultStorage, options) {\n  const getOnInit = options == null ? void 0 : options.getOnInit;\n  const baseAtom = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)(\n    getOnInit ? storage.getItem(key, initialValue) : initialValue\n  );\n  if (( false ? 0 : void 0) !== \"production\") {\n    baseAtom.debugPrivate = true;\n  }\n  baseAtom.onMount = (setAtom) => {\n    setAtom(storage.getItem(key, initialValue));\n    let unsub;\n    if (storage.subscribe) {\n      unsub = storage.subscribe(key, setAtom, initialValue);\n    }\n    return unsub;\n  };\n  const anAtom = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)(\n    (get) => get(baseAtom),\n    (get, set, update) => {\n      const nextValue = typeof update === \"function\" ? update(get(baseAtom)) : update;\n      if (nextValue === RESET) {\n        set(baseAtom, initialValue);\n        return storage.removeItem(key);\n      }\n      if (nextValue instanceof Promise) {\n        return nextValue.then((resolvedValue) => {\n          set(baseAtom, resolvedValue);\n          return storage.setItem(key, resolvedValue);\n        });\n      }\n      set(baseAtom, nextValue);\n      return storage.setItem(key, nextValue);\n    }\n  );\n  return anAtom;\n}\n\nfunction atomWithObservable(getObservable, options) {\n  const returnResultData = (result) => {\n    if (\"e\" in result) {\n      throw result.e;\n    }\n    return result.d;\n  };\n  const observableResultAtom = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)((get) => {\n    var _a;\n    let observable = getObservable(get);\n    const itself = (_a = observable[Symbol.observable]) == null ? void 0 : _a.call(observable);\n    if (itself) {\n      observable = itself;\n    }\n    let resolve;\n    const makePending = () => new Promise((r) => {\n      resolve = r;\n    });\n    const initialResult = options && \"initialValue\" in options ? {\n      d: typeof options.initialValue === \"function\" ? options.initialValue() : options.initialValue\n    } : makePending();\n    let setResult;\n    let lastResult;\n    const listener = (result) => {\n      lastResult = result;\n      resolve == null ? void 0 : resolve(result);\n      setResult == null ? void 0 : setResult(result);\n    };\n    let subscription;\n    let timer;\n    const isNotMounted = () => !setResult;\n    const start = () => {\n      if (subscription) {\n        clearTimeout(timer);\n        subscription.unsubscribe();\n      }\n      subscription = observable.subscribe({\n        next: (d) => listener({ d }),\n        error: (e) => listener({ e }),\n        complete: () => {\n        }\n      });\n      if (isNotMounted() && (options == null ? void 0 : options.unstable_timeout)) {\n        timer = setTimeout(() => {\n          if (subscription) {\n            subscription.unsubscribe();\n            subscription = void 0;\n          }\n        }, options.unstable_timeout);\n      }\n    };\n    start();\n    const resultAtom = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)(lastResult || initialResult);\n    if (( false ? 0 : void 0) !== \"production\") {\n      resultAtom.debugPrivate = true;\n    }\n    resultAtom.onMount = (update) => {\n      setResult = update;\n      if (lastResult) {\n        update(lastResult);\n      }\n      if (subscription) {\n        clearTimeout(timer);\n      } else {\n        start();\n      }\n      return () => {\n        setResult = void 0;\n        if (subscription) {\n          subscription.unsubscribe();\n          subscription = void 0;\n        }\n      };\n    };\n    return [resultAtom, observable, makePending, start, isNotMounted];\n  });\n  if (( false ? 0 : void 0) !== \"production\") {\n    observableResultAtom.debugPrivate = true;\n  }\n  const observableAtom = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)(\n    (get) => {\n      const [resultAtom] = get(observableResultAtom);\n      const result = get(resultAtom);\n      if (result instanceof Promise) {\n        return result.then(returnResultData);\n      }\n      return returnResultData(result);\n    },\n    (get, set, data) => {\n      const [resultAtom, observable, makePending, start, isNotMounted] = get(observableResultAtom);\n      if (\"next\" in observable) {\n        if (isNotMounted()) {\n          set(resultAtom, makePending());\n          start();\n        }\n        observable.next(data);\n      } else {\n        throw new Error(\"observable is not subject\");\n      }\n    }\n  );\n  return observableAtom;\n}\n\nconst cache1$1 = /* @__PURE__ */ new WeakMap();\nconst memo1 = (create, dep1) => (cache1$1.has(dep1) ? cache1$1 : cache1$1.set(dep1, create())).get(dep1);\nconst isPromise$1 = (x) => x instanceof Promise;\nconst LOADING = { state: \"loading\" };\nfunction loadable(anAtom) {\n  return memo1(() => {\n    const loadableCache = /* @__PURE__ */ new WeakMap();\n    const refreshAtom = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)(0);\n    if (( false ? 0 : void 0) !== \"production\") {\n      refreshAtom.debugPrivate = true;\n    }\n    const derivedAtom = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)(\n      (get, { setSelf }) => {\n        get(refreshAtom);\n        let value;\n        try {\n          value = get(anAtom);\n        } catch (error) {\n          return { state: \"hasError\", error };\n        }\n        if (!isPromise$1(value)) {\n          return { state: \"hasData\", data: value };\n        }\n        const promise = value;\n        const cached1 = loadableCache.get(promise);\n        if (cached1) {\n          return cached1;\n        }\n        if (promise.status === \"fulfilled\") {\n          loadableCache.set(promise, { state: \"hasData\", data: promise.value });\n        } else if (promise.status === \"rejected\") {\n          loadableCache.set(promise, {\n            state: \"hasError\",\n            error: promise.reason\n          });\n        } else {\n          promise.then(\n            (data) => {\n              loadableCache.set(promise, { state: \"hasData\", data });\n            },\n            (error) => {\n              loadableCache.set(promise, { state: \"hasError\", error });\n            }\n          ).finally(setSelf);\n        }\n        const cached2 = loadableCache.get(promise);\n        if (cached2) {\n          return cached2;\n        }\n        loadableCache.set(promise, LOADING);\n        return LOADING;\n      },\n      (_get, set) => {\n        set(refreshAtom, (c) => c + 1);\n      }\n    );\n    if (( false ? 0 : void 0) !== \"production\") {\n      derivedAtom.debugPrivate = true;\n    }\n    return (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)((get) => get(derivedAtom));\n  }, anAtom);\n}\n\nconst getCached = (c, m, k) => (m.has(k) ? m : m.set(k, c())).get(k);\nconst cache1 = /* @__PURE__ */ new WeakMap();\nconst memo2 = (create, dep1, dep2) => {\n  const cache2 = getCached(() => /* @__PURE__ */ new WeakMap(), cache1, dep1);\n  return getCached(create, cache2, dep2);\n};\nconst isPromise = (x) => x instanceof Promise;\nconst defaultFallback = () => void 0;\nfunction unwrap(anAtom, fallback = defaultFallback) {\n  return memo2(\n    () => {\n      const promiseErrorCache = /* @__PURE__ */ new WeakMap();\n      const promiseResultCache = /* @__PURE__ */ new WeakMap();\n      const refreshAtom = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)(0);\n      if (( false ? 0 : void 0) !== \"production\") {\n        refreshAtom.debugPrivate = true;\n      }\n      const promiseAndValueAtom = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)(\n        (get, { setSelf }) => {\n          get(refreshAtom);\n          const prev = get(promiseAndValueAtom);\n          const promise = get(anAtom);\n          if (!isPromise(promise)) {\n            return { v: promise };\n          }\n          if (promise !== (prev == null ? void 0 : prev.p)) {\n            if (promise.status === \"fulfilled\") {\n              promiseResultCache.set(promise, promise.value);\n            } else if (promise.status === \"rejected\") {\n              promiseErrorCache.set(promise, promise.reason);\n            } else {\n              promise.then(\n                (v) => promiseResultCache.set(promise, v),\n                (e) => promiseErrorCache.set(promise, e)\n              ).finally(setSelf);\n            }\n          }\n          if (promiseErrorCache.has(promise)) {\n            throw promiseErrorCache.get(promise);\n          }\n          if (promiseResultCache.has(promise)) {\n            return {\n              p: promise,\n              v: promiseResultCache.get(promise)\n            };\n          }\n          if (prev && \"v\" in prev) {\n            return { p: promise, f: fallback(prev.v), v: prev.v };\n          }\n          return { p: promise, f: fallback() };\n        },\n        (_get, set) => {\n          set(refreshAtom, (c) => c + 1);\n        }\n      );\n      promiseAndValueAtom.init = void 0;\n      if (( false ? 0 : void 0) !== \"production\") {\n        promiseAndValueAtom.debugPrivate = true;\n      }\n      return (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)(\n        (get) => {\n          const state = get(promiseAndValueAtom);\n          if (\"f\" in state) {\n            return state.f;\n          }\n          return state.v;\n        },\n        (_get, set, ...args) => set(anAtom, ...args)\n      );\n    },\n    anAtom,\n    fallback\n  );\n}\n\nfunction atomWithRefresh(read, write) {\n  const refreshAtom = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)(0);\n  if (( false ? 0 : void 0) !== \"production\") {\n    refreshAtom.debugPrivate = true;\n  }\n  return (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)(\n    (get, options) => {\n      get(refreshAtom);\n      return read(get, options);\n    },\n    (get, set, ...args) => {\n      if (args.length === 0) {\n        set(refreshAtom, (c) => c + 1);\n      } else if (write) {\n        return write(get, set, ...args);\n      }\n    }\n  );\n}\n\nfunction atomWithLazy(makeInitial) {\n  const a = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_0__.atom)(void 0);\n  delete a.init;\n  Object.defineProperty(a, \"init\", {\n    get() {\n      return makeInitial();\n    }\n  });\n  return a;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam90YWkvZXNtL3ZhbmlsbGEvdXRpbHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFxQzs7QUFFckM7QUFDQSxHQUFHLE1BQWUsR0FBRyxDQUFvQjtBQUN6Qzs7QUFFQTtBQUNBLGlCQUFpQixtREFBSTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUyxtREFBSTtBQUNiO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtREFBSTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxNQUFlLEdBQUcsQ0FBb0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxtREFBSSxnQkFBZ0IsbURBQUk7QUFDMUUsU0FBUztBQUNUO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1EQUFJO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLFdBQVcsTUFBZSxHQUFHLENBQW9CO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxtREFBSTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsbURBQUk7QUFDZDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLG1EQUFJO0FBQzlCLE9BQU8sTUFBZSxHQUFHLENBQW9CO0FBQzdDO0FBQ0E7QUFDQSxpQkFBaUIsbURBQUk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixTQUFTLE1BQWUsR0FBRyxDQUFvQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1EQUFJO0FBQ3ZCO0FBQ0E7QUFDQSxPQUFPLE1BQWUsR0FBRyxDQUFvQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtREFBSTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG1EQUFJO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLEdBQUc7QUFDbkMsaUNBQWlDLEdBQUc7QUFDcEM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1EQUFJO0FBQzNCLFNBQVMsTUFBZSxHQUFHLENBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILE9BQU8sTUFBZSxHQUFHLENBQW9CO0FBQzdDO0FBQ0E7QUFDQSx5QkFBeUIsbURBQUk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtREFBSTtBQUM1QixTQUFTLE1BQWUsR0FBRyxDQUFvQjtBQUMvQztBQUNBO0FBQ0Esd0JBQXdCLG1EQUFJO0FBQzVCLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx1Q0FBdUM7QUFDOUUsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBLDJDQUEyQyx3QkFBd0I7QUFDbkUsYUFBYTtBQUNiO0FBQ0EsMkNBQTJDLDBCQUEwQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLE1BQWUsR0FBRyxDQUFvQjtBQUMvQztBQUNBO0FBQ0EsV0FBVyxtREFBSTtBQUNmLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtREFBSTtBQUM5QixXQUFXLE1BQWUsR0FBRyxDQUFvQjtBQUNqRDtBQUNBO0FBQ0Esa0NBQWtDLG1EQUFJO0FBQ3RDLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsbUJBQW1CO0FBQ25CLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFlLEdBQUcsQ0FBb0I7QUFDakQ7QUFDQTtBQUNBLGFBQWEsbURBQUk7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsbURBQUk7QUFDMUIsT0FBTyxNQUFlLEdBQUcsQ0FBb0I7QUFDN0M7QUFDQTtBQUNBLFNBQVMsbURBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLG1EQUFJO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFb1MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvam90YWkvZXNtL3ZhbmlsbGEvdXRpbHMubWpzPzZiM2YiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXRvbSB9IGZyb20gJ2pvdGFpL3ZhbmlsbGEnO1xuXG5jb25zdCBSRVNFVCA9IFN5bWJvbChcbiAgKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcIlJFU0VUXCIgOiBcIlwiXG4pO1xuXG5mdW5jdGlvbiBhdG9tV2l0aFJlc2V0KGluaXRpYWxWYWx1ZSkge1xuICBjb25zdCBhbkF0b20gPSBhdG9tKFxuICAgIGluaXRpYWxWYWx1ZSxcbiAgICAoZ2V0LCBzZXQsIHVwZGF0ZSkgPT4ge1xuICAgICAgY29uc3QgbmV4dFZhbHVlID0gdHlwZW9mIHVwZGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gdXBkYXRlKGdldChhbkF0b20pKSA6IHVwZGF0ZTtcbiAgICAgIHNldChhbkF0b20sIG5leHRWYWx1ZSA9PT0gUkVTRVQgPyBpbml0aWFsVmFsdWUgOiBuZXh0VmFsdWUpO1xuICAgIH1cbiAgKTtcbiAgcmV0dXJuIGFuQXRvbTtcbn1cblxuZnVuY3Rpb24gYXRvbVdpdGhSZWR1Y2VyKGluaXRpYWxWYWx1ZSwgcmVkdWNlcikge1xuICByZXR1cm4gYXRvbShpbml0aWFsVmFsdWUsIGZ1bmN0aW9uKGdldCwgc2V0LCBhY3Rpb24pIHtcbiAgICBzZXQodGhpcywgcmVkdWNlcihnZXQodGhpcyksIGFjdGlvbikpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYXRvbUZhbWlseShpbml0aWFsaXplQXRvbSwgYXJlRXF1YWwpIHtcbiAgbGV0IHNob3VsZFJlbW92ZSA9IG51bGw7XG4gIGNvbnN0IGF0b21zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgY3JlYXRlQXRvbSA9IChwYXJhbSkgPT4ge1xuICAgIGxldCBpdGVtO1xuICAgIGlmIChhcmVFcXVhbCA9PT0gdm9pZCAwKSB7XG4gICAgICBpdGVtID0gYXRvbXMuZ2V0KHBhcmFtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgYXRvbXMpIHtcbiAgICAgICAgaWYgKGFyZUVxdWFsKGtleSwgcGFyYW0pKSB7XG4gICAgICAgICAgaXRlbSA9IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpdGVtICE9PSB2b2lkIDApIHtcbiAgICAgIGlmIChzaG91bGRSZW1vdmUgPT0gbnVsbCA/IHZvaWQgMCA6IHNob3VsZFJlbW92ZShpdGVtWzFdLCBwYXJhbSkpIHtcbiAgICAgICAgY3JlYXRlQXRvbS5yZW1vdmUocGFyYW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGl0ZW1bMF07XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5ld0F0b20gPSBpbml0aWFsaXplQXRvbShwYXJhbSk7XG4gICAgYXRvbXMuc2V0KHBhcmFtLCBbbmV3QXRvbSwgRGF0ZS5ub3coKV0pO1xuICAgIHJldHVybiBuZXdBdG9tO1xuICB9O1xuICBjcmVhdGVBdG9tLnJlbW92ZSA9IChwYXJhbSkgPT4ge1xuICAgIGlmIChhcmVFcXVhbCA9PT0gdm9pZCAwKSB7XG4gICAgICBhdG9tcy5kZWxldGUocGFyYW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGNvbnN0IFtrZXldIG9mIGF0b21zKSB7XG4gICAgICAgIGlmIChhcmVFcXVhbChrZXksIHBhcmFtKSkge1xuICAgICAgICAgIGF0b21zLmRlbGV0ZShrZXkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjcmVhdGVBdG9tLnNldFNob3VsZFJlbW92ZSA9IChmbikgPT4ge1xuICAgIHNob3VsZFJlbW92ZSA9IGZuO1xuICAgIGlmICghc2hvdWxkUmVtb3ZlKSByZXR1cm47XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgYXRvbXMpIHtcbiAgICAgIGlmIChzaG91bGRSZW1vdmUodmFsdWVbMV0sIGtleSkpIHtcbiAgICAgICAgYXRvbXMuZGVsZXRlKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gY3JlYXRlQXRvbTtcbn1cblxuY29uc3QgZ2V0Q2FjaGVkJDIgPSAoYywgbSwgaykgPT4gKG0uaGFzKGspID8gbSA6IG0uc2V0KGssIGMoKSkpLmdldChrKTtcbmNvbnN0IGNhY2hlMSQzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jb25zdCBtZW1vMyA9IChjcmVhdGUsIGRlcDEsIGRlcDIsIGRlcDMpID0+IHtcbiAgY29uc3QgY2FjaGUyID0gZ2V0Q2FjaGVkJDIoKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIGNhY2hlMSQzLCBkZXAxKTtcbiAgY29uc3QgY2FjaGUzID0gZ2V0Q2FjaGVkJDIoKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIGNhY2hlMiwgZGVwMik7XG4gIHJldHVybiBnZXRDYWNoZWQkMihjcmVhdGUsIGNhY2hlMywgZGVwMyk7XG59O1xuZnVuY3Rpb24gc2VsZWN0QXRvbShhbkF0b20sIHNlbGVjdG9yLCBlcXVhbGl0eUZuID0gT2JqZWN0LmlzKSB7XG4gIHJldHVybiBtZW1vMyhcbiAgICAoKSA9PiB7XG4gICAgICBjb25zdCBFTVBUWSA9IFN5bWJvbCgpO1xuICAgICAgY29uc3Qgc2VsZWN0VmFsdWUgPSAoW3ZhbHVlLCBwcmV2U2xpY2VdKSA9PiB7XG4gICAgICAgIGlmIChwcmV2U2xpY2UgPT09IEVNUFRZKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGVjdG9yKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzbGljZSA9IHNlbGVjdG9yKHZhbHVlLCBwcmV2U2xpY2UpO1xuICAgICAgICByZXR1cm4gZXF1YWxpdHlGbihwcmV2U2xpY2UsIHNsaWNlKSA/IHByZXZTbGljZSA6IHNsaWNlO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGRlcml2ZWRBdG9tID0gYXRvbSgoZ2V0KSA9PiB7XG4gICAgICAgIGNvbnN0IHByZXYgPSBnZXQoZGVyaXZlZEF0b20pO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGdldChhbkF0b20pO1xuICAgICAgICByZXR1cm4gc2VsZWN0VmFsdWUoW3ZhbHVlLCBwcmV2XSk7XG4gICAgICB9KTtcbiAgICAgIGRlcml2ZWRBdG9tLmluaXQgPSBFTVBUWTtcbiAgICAgIHJldHVybiBkZXJpdmVkQXRvbTtcbiAgICB9LFxuICAgIGFuQXRvbSxcbiAgICBzZWxlY3RvcixcbiAgICBlcXVhbGl0eUZuXG4gICk7XG59XG5cbmNvbnN0IGZyb3plbkF0b21zID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCk7XG5jb25zdCBkZWVwRnJlZXplID0gKG9iaikgPT4ge1xuICBpZiAodHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiB8fCBvYmogPT09IG51bGwpIHJldHVybjtcbiAgT2JqZWN0LmZyZWV6ZShvYmopO1xuICBjb25zdCBwcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopO1xuICBmb3IgKGNvbnN0IG5hbWUgb2YgcHJvcE5hbWVzKSB7XG4gICAgY29uc3QgdmFsdWUgPSBvYmpbbmFtZV07XG4gICAgZGVlcEZyZWV6ZSh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn07XG5mdW5jdGlvbiBmcmVlemVBdG9tKGFuQXRvbSkge1xuICBpZiAoZnJvemVuQXRvbXMuaGFzKGFuQXRvbSkpIHtcbiAgICByZXR1cm4gYW5BdG9tO1xuICB9XG4gIGZyb3plbkF0b21zLmFkZChhbkF0b20pO1xuICBjb25zdCBvcmlnUmVhZCA9IGFuQXRvbS5yZWFkO1xuICBhbkF0b20ucmVhZCA9IGZ1bmN0aW9uKGdldCwgb3B0aW9ucykge1xuICAgIHJldHVybiBkZWVwRnJlZXplKG9yaWdSZWFkLmNhbGwodGhpcywgZ2V0LCBvcHRpb25zKSk7XG4gIH07XG4gIGlmIChcIndyaXRlXCIgaW4gYW5BdG9tKSB7XG4gICAgY29uc3Qgb3JpZ1dyaXRlID0gYW5BdG9tLndyaXRlO1xuICAgIGFuQXRvbS53cml0ZSA9IGZ1bmN0aW9uKGdldCwgc2V0LCAuLi5hcmdzKSB7XG4gICAgICByZXR1cm4gb3JpZ1dyaXRlLmNhbGwoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIGdldCxcbiAgICAgICAgKC4uLnNldEFyZ3MpID0+IHtcbiAgICAgICAgICBpZiAoc2V0QXJnc1swXSA9PT0gYW5BdG9tKSB7XG4gICAgICAgICAgICBzZXRBcmdzWzFdID0gZGVlcEZyZWV6ZShzZXRBcmdzWzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNldCguLi5zZXRBcmdzKTtcbiAgICAgICAgfSxcbiAgICAgICAgLi4uYXJnc1xuICAgICAgKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBhbkF0b207XG59XG5mdW5jdGlvbiBmcmVlemVBdG9tQ3JlYXRvcihjcmVhdGVBdG9tKSB7XG4gIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIFwiW0RFUFJFQ0FURURdIGZyZWV6ZUF0b21DcmVhdG9yIGlzIGRlcHJlY2F0ZWQsIGRlZmluZSBpdCBvbiB1c2VycyBlbmRcIlxuICAgICk7XG4gIH1cbiAgcmV0dXJuICguLi5hcmdzKSA9PiBmcmVlemVBdG9tKGNyZWF0ZUF0b20oLi4uYXJncykpO1xufVxuXG5jb25zdCBnZXRDYWNoZWQkMSA9IChjLCBtLCBrKSA9PiAobS5oYXMoaykgPyBtIDogbS5zZXQoaywgYygpKSkuZ2V0KGspO1xuY29uc3QgY2FjaGUxJDIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IG1lbW8yJDEgPSAoY3JlYXRlLCBkZXAxLCBkZXAyKSA9PiB7XG4gIGNvbnN0IGNhY2hlMiA9IGdldENhY2hlZCQxKCgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBjYWNoZTEkMiwgZGVwMSk7XG4gIHJldHVybiBnZXRDYWNoZWQkMShjcmVhdGUsIGNhY2hlMiwgZGVwMik7XG59O1xuY29uc3QgY2FjaGVLZXlGb3JFbXB0eUtleUV4dHJhY3RvciA9IHt9O1xuY29uc3QgaXNXcml0YWJsZSA9IChhdG9tMikgPT4gISFhdG9tMi53cml0ZTtcbmNvbnN0IGlzRnVuY3Rpb24gPSAoeCkgPT4gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIjtcbmZ1bmN0aW9uIHNwbGl0QXRvbShhcnJBdG9tLCBrZXlFeHRyYWN0b3IpIHtcbiAgcmV0dXJuIG1lbW8yJDEoXG4gICAgKCkgPT4ge1xuICAgICAgY29uc3QgbWFwcGluZ0NhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gICAgICBjb25zdCBnZXRNYXBwaW5nID0gKGFyciwgcHJldikgPT4ge1xuICAgICAgICBsZXQgbWFwcGluZyA9IG1hcHBpbmdDYWNoZS5nZXQoYXJyKTtcbiAgICAgICAgaWYgKG1hcHBpbmcpIHtcbiAgICAgICAgICByZXR1cm4gbWFwcGluZztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2TWFwcGluZyA9IHByZXYgJiYgbWFwcGluZ0NhY2hlLmdldChwcmV2KTtcbiAgICAgICAgY29uc3QgYXRvbUxpc3QgPSBbXTtcbiAgICAgICAgY29uc3Qga2V5TGlzdCA9IFtdO1xuICAgICAgICBhcnIuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICBjb25zdCBrZXkgPSBrZXlFeHRyYWN0b3IgPyBrZXlFeHRyYWN0b3IoaXRlbSkgOiBpbmRleDtcbiAgICAgICAgICBrZXlMaXN0W2luZGV4XSA9IGtleTtcbiAgICAgICAgICBjb25zdCBjYWNoZWRBdG9tID0gcHJldk1hcHBpbmcgJiYgcHJldk1hcHBpbmcuYXRvbUxpc3RbcHJldk1hcHBpbmcua2V5TGlzdC5pbmRleE9mKGtleSldO1xuICAgICAgICAgIGlmIChjYWNoZWRBdG9tKSB7XG4gICAgICAgICAgICBhdG9tTGlzdFtpbmRleF0gPSBjYWNoZWRBdG9tO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCByZWFkID0gKGdldCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJldjIgPSBnZXQobWFwcGluZ0F0b20pO1xuICAgICAgICAgICAgY29uc3QgY3VyckFyciA9IGdldChhcnJBdG9tKTtcbiAgICAgICAgICAgIGNvbnN0IG1hcHBpbmcyID0gZ2V0TWFwcGluZyhjdXJyQXJyLCBwcmV2MiA9PSBudWxsID8gdm9pZCAwIDogcHJldjIuYXJyKTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4MiA9IG1hcHBpbmcyLmtleUxpc3QuaW5kZXhPZihrZXkpO1xuICAgICAgICAgICAgaWYgKGluZGV4MiA8IDAgfHwgaW5kZXgyID49IGN1cnJBcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHByZXZJdGVtID0gYXJyW2dldE1hcHBpbmcoYXJyKS5rZXlMaXN0LmluZGV4T2Yoa2V5KV07XG4gICAgICAgICAgICAgIGlmIChwcmV2SXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmV2SXRlbTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzcGxpdEF0b206IGluZGV4IG91dCBvZiBib3VuZHMgZm9yIHJlYWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3VyckFycltpbmRleDJdO1xuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3Qgd3JpdGUgPSAoZ2V0LCBzZXQsIHVwZGF0ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJldjIgPSBnZXQobWFwcGluZ0F0b20pO1xuICAgICAgICAgICAgY29uc3QgYXJyMiA9IGdldChhcnJBdG9tKTtcbiAgICAgICAgICAgIGNvbnN0IG1hcHBpbmcyID0gZ2V0TWFwcGluZyhhcnIyLCBwcmV2MiA9PSBudWxsID8gdm9pZCAwIDogcHJldjIuYXJyKTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4MiA9IG1hcHBpbmcyLmtleUxpc3QuaW5kZXhPZihrZXkpO1xuICAgICAgICAgICAgaWYgKGluZGV4MiA8IDAgfHwgaW5kZXgyID49IGFycjIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInNwbGl0QXRvbTogaW5kZXggb3V0IG9mIGJvdW5kcyBmb3Igd3JpdGVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZXh0SXRlbSA9IGlzRnVuY3Rpb24odXBkYXRlKSA/IHVwZGF0ZShhcnIyW2luZGV4Ml0pIDogdXBkYXRlO1xuICAgICAgICAgICAgaWYgKCFPYmplY3QuaXMoYXJyMltpbmRleDJdLCBuZXh0SXRlbSkpIHtcbiAgICAgICAgICAgICAgc2V0KGFyckF0b20sIFtcbiAgICAgICAgICAgICAgICAuLi5hcnIyLnNsaWNlKDAsIGluZGV4MiksXG4gICAgICAgICAgICAgICAgbmV4dEl0ZW0sXG4gICAgICAgICAgICAgICAgLi4uYXJyMi5zbGljZShpbmRleDIgKyAxKVxuICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGF0b21MaXN0W2luZGV4XSA9IGlzV3JpdGFibGUoYXJyQXRvbSkgPyBhdG9tKHJlYWQsIHdyaXRlKSA6IGF0b20ocmVhZCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocHJldk1hcHBpbmcgJiYgcHJldk1hcHBpbmcua2V5TGlzdC5sZW5ndGggPT09IGtleUxpc3QubGVuZ3RoICYmIHByZXZNYXBwaW5nLmtleUxpc3QuZXZlcnkoKHgsIGkpID0+IHggPT09IGtleUxpc3RbaV0pKSB7XG4gICAgICAgICAgbWFwcGluZyA9IHByZXZNYXBwaW5nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hcHBpbmcgPSB7IGFyciwgYXRvbUxpc3QsIGtleUxpc3QgfTtcbiAgICAgICAgfVxuICAgICAgICBtYXBwaW5nQ2FjaGUuc2V0KGFyciwgbWFwcGluZyk7XG4gICAgICAgIHJldHVybiBtYXBwaW5nO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IG1hcHBpbmdBdG9tID0gYXRvbSgoZ2V0KSA9PiB7XG4gICAgICAgIGNvbnN0IHByZXYgPSBnZXQobWFwcGluZ0F0b20pO1xuICAgICAgICBjb25zdCBhcnIgPSBnZXQoYXJyQXRvbSk7XG4gICAgICAgIGNvbnN0IG1hcHBpbmcgPSBnZXRNYXBwaW5nKGFyciwgcHJldiA9PSBudWxsID8gdm9pZCAwIDogcHJldi5hcnIpO1xuICAgICAgICByZXR1cm4gbWFwcGluZztcbiAgICAgIH0pO1xuICAgICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIG1hcHBpbmdBdG9tLmRlYnVnUHJpdmF0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBtYXBwaW5nQXRvbS5pbml0ID0gdm9pZCAwO1xuICAgICAgY29uc3Qgc3BsaXR0ZWRBdG9tID0gaXNXcml0YWJsZShhcnJBdG9tKSA/IGF0b20oXG4gICAgICAgIChnZXQpID0+IGdldChtYXBwaW5nQXRvbSkuYXRvbUxpc3QsXG4gICAgICAgIChnZXQsIHNldCwgYWN0aW9uKSA9PiB7XG4gICAgICAgICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcInJlbW92ZVwiOiB7XG4gICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gZ2V0KHNwbGl0dGVkQXRvbSkuaW5kZXhPZihhY3Rpb24uYXRvbSk7XG4gICAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJyID0gZ2V0KGFyckF0b20pO1xuICAgICAgICAgICAgICAgIHNldChhcnJBdG9tLCBbXG4gICAgICAgICAgICAgICAgICAuLi5hcnIuc2xpY2UoMCwgaW5kZXgpLFxuICAgICAgICAgICAgICAgICAgLi4uYXJyLnNsaWNlKGluZGV4ICsgMSlcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJpbnNlcnRcIjoge1xuICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGFjdGlvbi5iZWZvcmUgPyBnZXQoc3BsaXR0ZWRBdG9tKS5pbmRleE9mKGFjdGlvbi5iZWZvcmUpIDogZ2V0KHNwbGl0dGVkQXRvbSkubGVuZ3RoO1xuICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyciA9IGdldChhcnJBdG9tKTtcbiAgICAgICAgICAgICAgICBzZXQoYXJyQXRvbSwgW1xuICAgICAgICAgICAgICAgICAgLi4uYXJyLnNsaWNlKDAsIGluZGV4KSxcbiAgICAgICAgICAgICAgICAgIGFjdGlvbi52YWx1ZSxcbiAgICAgICAgICAgICAgICAgIC4uLmFyci5zbGljZShpbmRleClcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJtb3ZlXCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgaW5kZXgxID0gZ2V0KHNwbGl0dGVkQXRvbSkuaW5kZXhPZihhY3Rpb24uYXRvbSk7XG4gICAgICAgICAgICAgIGNvbnN0IGluZGV4MiA9IGFjdGlvbi5iZWZvcmUgPyBnZXQoc3BsaXR0ZWRBdG9tKS5pbmRleE9mKGFjdGlvbi5iZWZvcmUpIDogZ2V0KHNwbGl0dGVkQXRvbSkubGVuZ3RoO1xuICAgICAgICAgICAgICBpZiAoaW5kZXgxID49IDAgJiYgaW5kZXgyID49IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcnIgPSBnZXQoYXJyQXRvbSk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4MSA8IGluZGV4Mikge1xuICAgICAgICAgICAgICAgICAgc2V0KGFyckF0b20sIFtcbiAgICAgICAgICAgICAgICAgICAgLi4uYXJyLnNsaWNlKDAsIGluZGV4MSksXG4gICAgICAgICAgICAgICAgICAgIC4uLmFyci5zbGljZShpbmRleDEgKyAxLCBpbmRleDIpLFxuICAgICAgICAgICAgICAgICAgICBhcnJbaW5kZXgxXSxcbiAgICAgICAgICAgICAgICAgICAgLi4uYXJyLnNsaWNlKGluZGV4MilcbiAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzZXQoYXJyQXRvbSwgW1xuICAgICAgICAgICAgICAgICAgICAuLi5hcnIuc2xpY2UoMCwgaW5kZXgyKSxcbiAgICAgICAgICAgICAgICAgICAgYXJyW2luZGV4MV0sXG4gICAgICAgICAgICAgICAgICAgIC4uLmFyci5zbGljZShpbmRleDIsIGluZGV4MSksXG4gICAgICAgICAgICAgICAgICAgIC4uLmFyci5zbGljZShpbmRleDEgKyAxKVxuICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKSA6IGF0b20oKGdldCkgPT4gZ2V0KG1hcHBpbmdBdG9tKS5hdG9tTGlzdCk7XG4gICAgICByZXR1cm4gc3BsaXR0ZWRBdG9tO1xuICAgIH0sXG4gICAgYXJyQXRvbSxcbiAgICBrZXlFeHRyYWN0b3IgfHwgY2FjaGVLZXlGb3JFbXB0eUtleUV4dHJhY3RvclxuICApO1xufVxuXG5mdW5jdGlvbiBhdG9tV2l0aERlZmF1bHQoZ2V0RGVmYXVsdCkge1xuICBjb25zdCBFTVBUWSA9IFN5bWJvbCgpO1xuICBjb25zdCBvdmVyd3JpdHRlbkF0b20gPSBhdG9tKEVNUFRZKTtcbiAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgb3ZlcndyaXR0ZW5BdG9tLmRlYnVnUHJpdmF0ZSA9IHRydWU7XG4gIH1cbiAgY29uc3QgYW5BdG9tID0gYXRvbShcbiAgICAoZ2V0LCBvcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCBvdmVyd3JpdHRlbiA9IGdldChvdmVyd3JpdHRlbkF0b20pO1xuICAgICAgaWYgKG92ZXJ3cml0dGVuICE9PSBFTVBUWSkge1xuICAgICAgICByZXR1cm4gb3ZlcndyaXR0ZW47XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0RGVmYXVsdChnZXQsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgKGdldCwgc2V0LCB1cGRhdGUpID0+IHtcbiAgICAgIGlmICh1cGRhdGUgPT09IFJFU0VUKSB7XG4gICAgICAgIHNldChvdmVyd3JpdHRlbkF0b20sIEVNUFRZKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHVwZGF0ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IHByZXZWYWx1ZSA9IGdldChhbkF0b20pO1xuICAgICAgICBzZXQob3ZlcndyaXR0ZW5BdG9tLCB1cGRhdGUocHJldlZhbHVlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXQob3ZlcndyaXR0ZW5BdG9tLCB1cGRhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgKTtcbiAgcmV0dXJuIGFuQXRvbTtcbn1cblxuY29uc3QgaXNQcm9taXNlTGlrZSA9ICh4KSA9PiB0eXBlb2YgKHggPT0gbnVsbCA/IHZvaWQgMCA6IHgudGhlbikgPT09IFwiZnVuY3Rpb25cIjtcbmZ1bmN0aW9uIHdpdGhTdG9yYWdlVmFsaWRhdG9yKHZhbGlkYXRvcikge1xuICByZXR1cm4gKHVua25vd25TdG9yYWdlKSA9PiB7XG4gICAgY29uc3Qgc3RvcmFnZSA9IHtcbiAgICAgIC4uLnVua25vd25TdG9yYWdlLFxuICAgICAgZ2V0SXRlbTogKGtleSwgaW5pdGlhbFZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRlID0gKHZhbHVlMikgPT4ge1xuICAgICAgICAgIGlmICghdmFsaWRhdG9yKHZhbHVlMikpIHtcbiAgICAgICAgICAgIHJldHVybiBpbml0aWFsVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWx1ZTI7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdW5rbm93blN0b3JhZ2UuZ2V0SXRlbShrZXksIGluaXRpYWxWYWx1ZSk7XG4gICAgICAgIGlmIChpc1Byb21pc2VMaWtlKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZS50aGVuKHZhbGlkYXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsaWRhdGUodmFsdWUpO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHN0b3JhZ2U7XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVKU09OU3RvcmFnZShnZXRTdHJpbmdTdG9yYWdlID0gKCkgPT4ge1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBjb25zb2xlLndhcm4oZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbn0sIG9wdGlvbnMpIHtcbiAgdmFyIF9hO1xuICBsZXQgbGFzdFN0cjtcbiAgbGV0IGxhc3RWYWx1ZTtcbiAgY29uc3Qgc3RvcmFnZSA9IHtcbiAgICBnZXRJdGVtOiAoa2V5LCBpbml0aWFsVmFsdWUpID0+IHtcbiAgICAgIHZhciBfYTIsIF9iO1xuICAgICAgY29uc3QgcGFyc2UgPSAoc3RyMikgPT4ge1xuICAgICAgICBzdHIyID0gc3RyMiB8fCBcIlwiO1xuICAgICAgICBpZiAobGFzdFN0ciAhPT0gc3RyMikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsYXN0VmFsdWUgPSBKU09OLnBhcnNlKHN0cjIsIG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMucmV2aXZlcik7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGluaXRpYWxWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGFzdFN0ciA9IHN0cjI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxhc3RWYWx1ZTtcbiAgICAgIH07XG4gICAgICBjb25zdCBzdHIgPSAoX2IgPSAoX2EyID0gZ2V0U3RyaW5nU3RvcmFnZSgpKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmdldEl0ZW0oa2V5KSkgIT0gbnVsbCA/IF9iIDogbnVsbDtcbiAgICAgIGlmIChpc1Byb21pc2VMaWtlKHN0cikpIHtcbiAgICAgICAgcmV0dXJuIHN0ci50aGVuKHBhcnNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZShzdHIpO1xuICAgIH0sXG4gICAgc2V0SXRlbTogKGtleSwgbmV3VmFsdWUpID0+IHtcbiAgICAgIHZhciBfYTI7XG4gICAgICByZXR1cm4gKF9hMiA9IGdldFN0cmluZ1N0b3JhZ2UoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5zZXRJdGVtKFxuICAgICAgICBrZXksXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KG5ld1ZhbHVlLCBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnJlcGxhY2VyKVxuICAgICAgKTtcbiAgICB9LFxuICAgIHJlbW92ZUl0ZW06IChrZXkpID0+IHtcbiAgICAgIHZhciBfYTI7XG4gICAgICByZXR1cm4gKF9hMiA9IGdldFN0cmluZ1N0b3JhZ2UoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5yZW1vdmVJdGVtKGtleSk7XG4gICAgfVxuICB9O1xuICBjb25zdCBjcmVhdGVIYW5kbGVTdWJzY3JpYmUgPSAoc3Vic2NyaWJlcjIpID0+IChrZXksIGNhbGxiYWNrLCBpbml0aWFsVmFsdWUpID0+IHN1YnNjcmliZXIyKGtleSwgKHYpID0+IHtcbiAgICBsZXQgbmV3VmFsdWU7XG4gICAgdHJ5IHtcbiAgICAgIG5ld1ZhbHVlID0gSlNPTi5wYXJzZSh2IHx8IFwiXCIpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIG5ld1ZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICAgIH1cbiAgICBjYWxsYmFjayhuZXdWYWx1ZSk7XG4gIH0pO1xuICBsZXQgc3Vic2NyaWJlcjtcbiAgdHJ5IHtcbiAgICBzdWJzY3JpYmVyID0gKF9hID0gZ2V0U3RyaW5nU3RvcmFnZSgpKSA9PSBudWxsID8gdm9pZCAwIDogX2Euc3Vic2NyaWJlO1xuICB9IGNhdGNoIChlKSB7XG4gIH1cbiAgaWYgKCFzdWJzY3JpYmVyICYmIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyID09PSBcImZ1bmN0aW9uXCIgJiYgd2luZG93LlN0b3JhZ2UpIHtcbiAgICBzdWJzY3JpYmVyID0gKGtleSwgY2FsbGJhY2spID0+IHtcbiAgICAgIGlmICghKGdldFN0cmluZ1N0b3JhZ2UoKSBpbnN0YW5jZW9mIHdpbmRvdy5TdG9yYWdlKSkge1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RvcmFnZUV2ZW50Q2FsbGJhY2sgPSAoZSkgPT4ge1xuICAgICAgICBpZiAoZS5zdG9yYWdlQXJlYSA9PT0gZ2V0U3RyaW5nU3RvcmFnZSgpICYmIGUua2V5ID09PSBrZXkpIHtcbiAgICAgICAgICBjYWxsYmFjayhlLm5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwic3RvcmFnZVwiLCBzdG9yYWdlRXZlbnRDYWxsYmFjayk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInN0b3JhZ2VcIiwgc3RvcmFnZUV2ZW50Q2FsbGJhY2spO1xuICAgICAgfTtcbiAgICB9O1xuICB9XG4gIGlmIChzdWJzY3JpYmVyKSB7XG4gICAgc3RvcmFnZS5zdWJzY3JpYmUgPSBjcmVhdGVIYW5kbGVTdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gIH1cbiAgcmV0dXJuIHN0b3JhZ2U7XG59XG5jb25zdCBkZWZhdWx0U3RvcmFnZSA9IGNyZWF0ZUpTT05TdG9yYWdlKCk7XG5mdW5jdGlvbiBhdG9tV2l0aFN0b3JhZ2Uoa2V5LCBpbml0aWFsVmFsdWUsIHN0b3JhZ2UgPSBkZWZhdWx0U3RvcmFnZSwgb3B0aW9ucykge1xuICBjb25zdCBnZXRPbkluaXQgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmdldE9uSW5pdDtcbiAgY29uc3QgYmFzZUF0b20gPSBhdG9tKFxuICAgIGdldE9uSW5pdCA/IHN0b3JhZ2UuZ2V0SXRlbShrZXksIGluaXRpYWxWYWx1ZSkgOiBpbml0aWFsVmFsdWVcbiAgKTtcbiAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgYmFzZUF0b20uZGVidWdQcml2YXRlID0gdHJ1ZTtcbiAgfVxuICBiYXNlQXRvbS5vbk1vdW50ID0gKHNldEF0b20pID0+IHtcbiAgICBzZXRBdG9tKHN0b3JhZ2UuZ2V0SXRlbShrZXksIGluaXRpYWxWYWx1ZSkpO1xuICAgIGxldCB1bnN1YjtcbiAgICBpZiAoc3RvcmFnZS5zdWJzY3JpYmUpIHtcbiAgICAgIHVuc3ViID0gc3RvcmFnZS5zdWJzY3JpYmUoa2V5LCBzZXRBdG9tLCBpbml0aWFsVmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdW5zdWI7XG4gIH07XG4gIGNvbnN0IGFuQXRvbSA9IGF0b20oXG4gICAgKGdldCkgPT4gZ2V0KGJhc2VBdG9tKSxcbiAgICAoZ2V0LCBzZXQsIHVwZGF0ZSkgPT4ge1xuICAgICAgY29uc3QgbmV4dFZhbHVlID0gdHlwZW9mIHVwZGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gdXBkYXRlKGdldChiYXNlQXRvbSkpIDogdXBkYXRlO1xuICAgICAgaWYgKG5leHRWYWx1ZSA9PT0gUkVTRVQpIHtcbiAgICAgICAgc2V0KGJhc2VBdG9tLCBpbml0aWFsVmFsdWUpO1xuICAgICAgICByZXR1cm4gc3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgICB9XG4gICAgICBpZiAobmV4dFZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICByZXR1cm4gbmV4dFZhbHVlLnRoZW4oKHJlc29sdmVkVmFsdWUpID0+IHtcbiAgICAgICAgICBzZXQoYmFzZUF0b20sIHJlc29sdmVkVmFsdWUpO1xuICAgICAgICAgIHJldHVybiBzdG9yYWdlLnNldEl0ZW0oa2V5LCByZXNvbHZlZFZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBzZXQoYmFzZUF0b20sIG5leHRWYWx1ZSk7XG4gICAgICByZXR1cm4gc3RvcmFnZS5zZXRJdGVtKGtleSwgbmV4dFZhbHVlKTtcbiAgICB9XG4gICk7XG4gIHJldHVybiBhbkF0b207XG59XG5cbmZ1bmN0aW9uIGF0b21XaXRoT2JzZXJ2YWJsZShnZXRPYnNlcnZhYmxlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHJldHVyblJlc3VsdERhdGEgPSAocmVzdWx0KSA9PiB7XG4gICAgaWYgKFwiZVwiIGluIHJlc3VsdCkge1xuICAgICAgdGhyb3cgcmVzdWx0LmU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQuZDtcbiAgfTtcbiAgY29uc3Qgb2JzZXJ2YWJsZVJlc3VsdEF0b20gPSBhdG9tKChnZXQpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IG9ic2VydmFibGUgPSBnZXRPYnNlcnZhYmxlKGdldCk7XG4gICAgY29uc3QgaXRzZWxmID0gKF9hID0gb2JzZXJ2YWJsZVtTeW1ib2wub2JzZXJ2YWJsZV0pID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKG9ic2VydmFibGUpO1xuICAgIGlmIChpdHNlbGYpIHtcbiAgICAgIG9ic2VydmFibGUgPSBpdHNlbGY7XG4gICAgfVxuICAgIGxldCByZXNvbHZlO1xuICAgIGNvbnN0IG1ha2VQZW5kaW5nID0gKCkgPT4gbmV3IFByb21pc2UoKHIpID0+IHtcbiAgICAgIHJlc29sdmUgPSByO1xuICAgIH0pO1xuICAgIGNvbnN0IGluaXRpYWxSZXN1bHQgPSBvcHRpb25zICYmIFwiaW5pdGlhbFZhbHVlXCIgaW4gb3B0aW9ucyA/IHtcbiAgICAgIGQ6IHR5cGVvZiBvcHRpb25zLmluaXRpYWxWYWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gb3B0aW9ucy5pbml0aWFsVmFsdWUoKSA6IG9wdGlvbnMuaW5pdGlhbFZhbHVlXG4gICAgfSA6IG1ha2VQZW5kaW5nKCk7XG4gICAgbGV0IHNldFJlc3VsdDtcbiAgICBsZXQgbGFzdFJlc3VsdDtcbiAgICBjb25zdCBsaXN0ZW5lciA9IChyZXN1bHQpID0+IHtcbiAgICAgIGxhc3RSZXN1bHQgPSByZXN1bHQ7XG4gICAgICByZXNvbHZlID09IG51bGwgPyB2b2lkIDAgOiByZXNvbHZlKHJlc3VsdCk7XG4gICAgICBzZXRSZXN1bHQgPT0gbnVsbCA/IHZvaWQgMCA6IHNldFJlc3VsdChyZXN1bHQpO1xuICAgIH07XG4gICAgbGV0IHN1YnNjcmlwdGlvbjtcbiAgICBsZXQgdGltZXI7XG4gICAgY29uc3QgaXNOb3RNb3VudGVkID0gKCkgPT4gIXNldFJlc3VsdDtcbiAgICBjb25zdCBzdGFydCA9ICgpID0+IHtcbiAgICAgIGlmIChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICB9XG4gICAgICBzdWJzY3JpcHRpb24gPSBvYnNlcnZhYmxlLnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQ6IChkKSA9PiBsaXN0ZW5lcih7IGQgfSksXG4gICAgICAgIGVycm9yOiAoZSkgPT4gbGlzdGVuZXIoeyBlIH0pLFxuICAgICAgICBjb21wbGV0ZTogKCkgPT4ge1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChpc05vdE1vdW50ZWQoKSAmJiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy51bnN0YWJsZV90aW1lb3V0KSkge1xuICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uID0gdm9pZCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgb3B0aW9ucy51bnN0YWJsZV90aW1lb3V0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHN0YXJ0KCk7XG4gICAgY29uc3QgcmVzdWx0QXRvbSA9IGF0b20obGFzdFJlc3VsdCB8fCBpbml0aWFsUmVzdWx0KTtcbiAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHJlc3VsdEF0b20uZGVidWdQcml2YXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmVzdWx0QXRvbS5vbk1vdW50ID0gKHVwZGF0ZSkgPT4ge1xuICAgICAgc2V0UmVzdWx0ID0gdXBkYXRlO1xuICAgICAgaWYgKGxhc3RSZXN1bHQpIHtcbiAgICAgICAgdXBkYXRlKGxhc3RSZXN1bHQpO1xuICAgICAgfVxuICAgICAgaWYgKHN1YnNjcmlwdGlvbikge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHNldFJlc3VsdCA9IHZvaWQgMDtcbiAgICAgICAgaWYgKHN1YnNjcmlwdGlvbikge1xuICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIHN1YnNjcmlwdGlvbiA9IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBbcmVzdWx0QXRvbSwgb2JzZXJ2YWJsZSwgbWFrZVBlbmRpbmcsIHN0YXJ0LCBpc05vdE1vdW50ZWRdO1xuICB9KTtcbiAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgb2JzZXJ2YWJsZVJlc3VsdEF0b20uZGVidWdQcml2YXRlID0gdHJ1ZTtcbiAgfVxuICBjb25zdCBvYnNlcnZhYmxlQXRvbSA9IGF0b20oXG4gICAgKGdldCkgPT4ge1xuICAgICAgY29uc3QgW3Jlc3VsdEF0b21dID0gZ2V0KG9ic2VydmFibGVSZXN1bHRBdG9tKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGdldChyZXN1bHRBdG9tKTtcbiAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQudGhlbihyZXR1cm5SZXN1bHREYXRhKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXR1cm5SZXN1bHREYXRhKHJlc3VsdCk7XG4gICAgfSxcbiAgICAoZ2V0LCBzZXQsIGRhdGEpID0+IHtcbiAgICAgIGNvbnN0IFtyZXN1bHRBdG9tLCBvYnNlcnZhYmxlLCBtYWtlUGVuZGluZywgc3RhcnQsIGlzTm90TW91bnRlZF0gPSBnZXQob2JzZXJ2YWJsZVJlc3VsdEF0b20pO1xuICAgICAgaWYgKFwibmV4dFwiIGluIG9ic2VydmFibGUpIHtcbiAgICAgICAgaWYgKGlzTm90TW91bnRlZCgpKSB7XG4gICAgICAgICAgc2V0KHJlc3VsdEF0b20sIG1ha2VQZW5kaW5nKCkpO1xuICAgICAgICAgIHN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgb2JzZXJ2YWJsZS5uZXh0KGRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwib2JzZXJ2YWJsZSBpcyBub3Qgc3ViamVjdFwiKTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG4gIHJldHVybiBvYnNlcnZhYmxlQXRvbTtcbn1cblxuY29uc3QgY2FjaGUxJDEgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IG1lbW8xID0gKGNyZWF0ZSwgZGVwMSkgPT4gKGNhY2hlMSQxLmhhcyhkZXAxKSA/IGNhY2hlMSQxIDogY2FjaGUxJDEuc2V0KGRlcDEsIGNyZWF0ZSgpKSkuZ2V0KGRlcDEpO1xuY29uc3QgaXNQcm9taXNlJDEgPSAoeCkgPT4geCBpbnN0YW5jZW9mIFByb21pc2U7XG5jb25zdCBMT0FESU5HID0geyBzdGF0ZTogXCJsb2FkaW5nXCIgfTtcbmZ1bmN0aW9uIGxvYWRhYmxlKGFuQXRvbSkge1xuICByZXR1cm4gbWVtbzEoKCkgPT4ge1xuICAgIGNvbnN0IGxvYWRhYmxlQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgICBjb25zdCByZWZyZXNoQXRvbSA9IGF0b20oMCk7XG4gICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICByZWZyZXNoQXRvbS5kZWJ1Z1ByaXZhdGUgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBkZXJpdmVkQXRvbSA9IGF0b20oXG4gICAgICAoZ2V0LCB7IHNldFNlbGYgfSkgPT4ge1xuICAgICAgICBnZXQocmVmcmVzaEF0b20pO1xuICAgICAgICBsZXQgdmFsdWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFsdWUgPSBnZXQoYW5BdG9tKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4geyBzdGF0ZTogXCJoYXNFcnJvclwiLCBlcnJvciB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNQcm9taXNlJDEodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHsgc3RhdGU6IFwiaGFzRGF0YVwiLCBkYXRhOiB2YWx1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSB2YWx1ZTtcbiAgICAgICAgY29uc3QgY2FjaGVkMSA9IGxvYWRhYmxlQ2FjaGUuZ2V0KHByb21pc2UpO1xuICAgICAgICBpZiAoY2FjaGVkMSkge1xuICAgICAgICAgIHJldHVybiBjYWNoZWQxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9taXNlLnN0YXR1cyA9PT0gXCJmdWxmaWxsZWRcIikge1xuICAgICAgICAgIGxvYWRhYmxlQ2FjaGUuc2V0KHByb21pc2UsIHsgc3RhdGU6IFwiaGFzRGF0YVwiLCBkYXRhOiBwcm9taXNlLnZhbHVlIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHByb21pc2Uuc3RhdHVzID09PSBcInJlamVjdGVkXCIpIHtcbiAgICAgICAgICBsb2FkYWJsZUNhY2hlLnNldChwcm9taXNlLCB7XG4gICAgICAgICAgICBzdGF0ZTogXCJoYXNFcnJvclwiLFxuICAgICAgICAgICAgZXJyb3I6IHByb21pc2UucmVhc29uXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvbWlzZS50aGVuKFxuICAgICAgICAgICAgKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgbG9hZGFibGVDYWNoZS5zZXQocHJvbWlzZSwgeyBzdGF0ZTogXCJoYXNEYXRhXCIsIGRhdGEgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgIGxvYWRhYmxlQ2FjaGUuc2V0KHByb21pc2UsIHsgc3RhdGU6IFwiaGFzRXJyb3JcIiwgZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKS5maW5hbGx5KHNldFNlbGYpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhY2hlZDIgPSBsb2FkYWJsZUNhY2hlLmdldChwcm9taXNlKTtcbiAgICAgICAgaWYgKGNhY2hlZDIpIHtcbiAgICAgICAgICByZXR1cm4gY2FjaGVkMjtcbiAgICAgICAgfVxuICAgICAgICBsb2FkYWJsZUNhY2hlLnNldChwcm9taXNlLCBMT0FESU5HKTtcbiAgICAgICAgcmV0dXJuIExPQURJTkc7XG4gICAgICB9LFxuICAgICAgKF9nZXQsIHNldCkgPT4ge1xuICAgICAgICBzZXQocmVmcmVzaEF0b20sIChjKSA9PiBjICsgMSk7XG4gICAgICB9XG4gICAgKTtcbiAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGRlcml2ZWRBdG9tLmRlYnVnUHJpdmF0ZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBhdG9tKChnZXQpID0+IGdldChkZXJpdmVkQXRvbSkpO1xuICB9LCBhbkF0b20pO1xufVxuXG5jb25zdCBnZXRDYWNoZWQgPSAoYywgbSwgaykgPT4gKG0uaGFzKGspID8gbSA6IG0uc2V0KGssIGMoKSkpLmdldChrKTtcbmNvbnN0IGNhY2hlMSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuY29uc3QgbWVtbzIgPSAoY3JlYXRlLCBkZXAxLCBkZXAyKSA9PiB7XG4gIGNvbnN0IGNhY2hlMiA9IGdldENhY2hlZCgoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgY2FjaGUxLCBkZXAxKTtcbiAgcmV0dXJuIGdldENhY2hlZChjcmVhdGUsIGNhY2hlMiwgZGVwMik7XG59O1xuY29uc3QgaXNQcm9taXNlID0gKHgpID0+IHggaW5zdGFuY2VvZiBQcm9taXNlO1xuY29uc3QgZGVmYXVsdEZhbGxiYWNrID0gKCkgPT4gdm9pZCAwO1xuZnVuY3Rpb24gdW53cmFwKGFuQXRvbSwgZmFsbGJhY2sgPSBkZWZhdWx0RmFsbGJhY2spIHtcbiAgcmV0dXJuIG1lbW8yKFxuICAgICgpID0+IHtcbiAgICAgIGNvbnN0IHByb21pc2VFcnJvckNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gICAgICBjb25zdCBwcm9taXNlUmVzdWx0Q2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgICAgIGNvbnN0IHJlZnJlc2hBdG9tID0gYXRvbSgwKTtcbiAgICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICByZWZyZXNoQXRvbS5kZWJ1Z1ByaXZhdGUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgcHJvbWlzZUFuZFZhbHVlQXRvbSA9IGF0b20oXG4gICAgICAgIChnZXQsIHsgc2V0U2VsZiB9KSA9PiB7XG4gICAgICAgICAgZ2V0KHJlZnJlc2hBdG9tKTtcbiAgICAgICAgICBjb25zdCBwcmV2ID0gZ2V0KHByb21pc2VBbmRWYWx1ZUF0b20pO1xuICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBnZXQoYW5BdG9tKTtcbiAgICAgICAgICBpZiAoIWlzUHJvbWlzZShwcm9taXNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdjogcHJvbWlzZSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJvbWlzZSAhPT0gKHByZXYgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXYucCkpIHtcbiAgICAgICAgICAgIGlmIChwcm9taXNlLnN0YXR1cyA9PT0gXCJmdWxmaWxsZWRcIikge1xuICAgICAgICAgICAgICBwcm9taXNlUmVzdWx0Q2FjaGUuc2V0KHByb21pc2UsIHByb21pc2UudmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9taXNlLnN0YXR1cyA9PT0gXCJyZWplY3RlZFwiKSB7XG4gICAgICAgICAgICAgIHByb21pc2VFcnJvckNhY2hlLnNldChwcm9taXNlLCBwcm9taXNlLnJlYXNvbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwcm9taXNlLnRoZW4oXG4gICAgICAgICAgICAgICAgKHYpID0+IHByb21pc2VSZXN1bHRDYWNoZS5zZXQocHJvbWlzZSwgdiksXG4gICAgICAgICAgICAgICAgKGUpID0+IHByb21pc2VFcnJvckNhY2hlLnNldChwcm9taXNlLCBlKVxuICAgICAgICAgICAgICApLmZpbmFsbHkoc2V0U2VsZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcm9taXNlRXJyb3JDYWNoZS5oYXMocHJvbWlzZSkpIHtcbiAgICAgICAgICAgIHRocm93IHByb21pc2VFcnJvckNhY2hlLmdldChwcm9taXNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByb21pc2VSZXN1bHRDYWNoZS5oYXMocHJvbWlzZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHA6IHByb21pc2UsXG4gICAgICAgICAgICAgIHY6IHByb21pc2VSZXN1bHRDYWNoZS5nZXQocHJvbWlzZSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcmV2ICYmIFwidlwiIGluIHByZXYpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHA6IHByb21pc2UsIGY6IGZhbGxiYWNrKHByZXYudiksIHY6IHByZXYudiB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4geyBwOiBwcm9taXNlLCBmOiBmYWxsYmFjaygpIH07XG4gICAgICAgIH0sXG4gICAgICAgIChfZ2V0LCBzZXQpID0+IHtcbiAgICAgICAgICBzZXQocmVmcmVzaEF0b20sIChjKSA9PiBjICsgMSk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBwcm9taXNlQW5kVmFsdWVBdG9tLmluaXQgPSB2b2lkIDA7XG4gICAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgcHJvbWlzZUFuZFZhbHVlQXRvbS5kZWJ1Z1ByaXZhdGUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF0b20oXG4gICAgICAgIChnZXQpID0+IHtcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IGdldChwcm9taXNlQW5kVmFsdWVBdG9tKTtcbiAgICAgICAgICBpZiAoXCJmXCIgaW4gc3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZS5mO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc3RhdGUudjtcbiAgICAgICAgfSxcbiAgICAgICAgKF9nZXQsIHNldCwgLi4uYXJncykgPT4gc2V0KGFuQXRvbSwgLi4uYXJncylcbiAgICAgICk7XG4gICAgfSxcbiAgICBhbkF0b20sXG4gICAgZmFsbGJhY2tcbiAgKTtcbn1cblxuZnVuY3Rpb24gYXRvbVdpdGhSZWZyZXNoKHJlYWQsIHdyaXRlKSB7XG4gIGNvbnN0IHJlZnJlc2hBdG9tID0gYXRvbSgwKTtcbiAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgcmVmcmVzaEF0b20uZGVidWdQcml2YXRlID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gYXRvbShcbiAgICAoZ2V0LCBvcHRpb25zKSA9PiB7XG4gICAgICBnZXQocmVmcmVzaEF0b20pO1xuICAgICAgcmV0dXJuIHJlYWQoZ2V0LCBvcHRpb25zKTtcbiAgICB9LFxuICAgIChnZXQsIHNldCwgLi4uYXJncykgPT4ge1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHNldChyZWZyZXNoQXRvbSwgKGMpID0+IGMgKyAxKTtcbiAgICAgIH0gZWxzZSBpZiAod3JpdGUpIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlKGdldCwgc2V0LCAuLi5hcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG59XG5cbmZ1bmN0aW9uIGF0b21XaXRoTGF6eShtYWtlSW5pdGlhbCkge1xuICBjb25zdCBhID0gYXRvbSh2b2lkIDApO1xuICBkZWxldGUgYS5pbml0O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYSwgXCJpbml0XCIsIHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gbWFrZUluaXRpYWwoKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYTtcbn1cblxuZXhwb3J0IHsgUkVTRVQsIGF0b21GYW1pbHksIGF0b21XaXRoRGVmYXVsdCwgYXRvbVdpdGhMYXp5LCBhdG9tV2l0aE9ic2VydmFibGUsIGF0b21XaXRoUmVkdWNlciwgYXRvbVdpdGhSZWZyZXNoLCBhdG9tV2l0aFJlc2V0LCBhdG9tV2l0aFN0b3JhZ2UsIGNyZWF0ZUpTT05TdG9yYWdlLCBmcmVlemVBdG9tLCBmcmVlemVBdG9tQ3JlYXRvciwgbG9hZGFibGUsIHNlbGVjdEF0b20sIHNwbGl0QXRvbSwgd2l0aFN0b3JhZ2VWYWxpZGF0b3IgYXMgdW5zdGFibGVfd2l0aFN0b3JhZ2VWYWxpZGF0b3IsIHVud3JhcCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jotai/esm/vanilla/utils.mjs\n");

/***/ })

};
;